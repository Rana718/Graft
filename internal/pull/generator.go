package pull

import (
	"fmt"
	"strings"

	"github.com/Lumos-Labs-HQ/flash/internal/types"
)

// generateTableSQLClean generates clean table SQL without header comments
func (s *Service) generateTableSQLClean(table types.SchemaTable, indexes []types.SchemaIndex) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("CREATE TABLE %s (\n", table.Name))

	for i, col := range table.Columns {
		sb.WriteString(fmt.Sprintf("    %s %s", col.Name, col.Type))

		if col.IsPrimary {
			sb.WriteString(" PRIMARY KEY")
		}
		if col.IsAutoIncrement && !col.IsPrimary {
			sb.WriteString(" AUTOINCREMENT")
		}
		if !col.Nullable && !col.IsPrimary {
			sb.WriteString(" NOT NULL")
		}
		if col.IsUnique && !col.IsPrimary {
			sb.WriteString(" UNIQUE")
		}
		if col.Default != "" {
			sb.WriteString(fmt.Sprintf(" DEFAULT %s", col.Default))
		}
		if col.ForeignKeyTable != "" && col.ForeignKeyColumn != "" {
			sb.WriteString(fmt.Sprintf(" REFERENCES %s(%s)", col.ForeignKeyTable, col.ForeignKeyColumn))
			if col.OnDeleteAction != "" {
				sb.WriteString(fmt.Sprintf(" ON DELETE %s", col.OnDeleteAction))
			}
		}

		if i < len(table.Columns)-1 {
			sb.WriteString(",")
		}
		sb.WriteString("\n")
	}

	sb.WriteString(");")

	// Add indexes (skip internal SQLite indexes and primary key indexes)
	for _, idx := range indexes {
		if strings.HasSuffix(idx.Name, "_pkey") || idx.Name == "PRIMARY" || strings.HasPrefix(idx.Name, "sqlite_") {
			continue
		}

		indexType := ""
		if idx.Unique {
			indexType = "UNIQUE "
		}

		sb.WriteString(fmt.Sprintf("\nCREATE %sINDEX %s ON %s (%s);",
			indexType, idx.Name, table.Name, strings.Join(idx.Columns, ", ")))
	}

	return sb.String()
}

func (s *Service) generateTableSQL(table types.SchemaTable, indexes []types.SchemaIndex) string {
	var sb strings.Builder

	// Header comment
	sb.WriteString(fmt.Sprintf("-- Table: %s\n", table.Name))
	sb.WriteString("-- Auto-generated by flash pull\n\n")

	sb.WriteString(s.generateTableSQLClean(table, indexes))
	sb.WriteString("\n")

	return sb.String()
}

func (s *Service) generateEnumSQL(enums []types.SchemaEnum) string {
	if len(enums) == 0 {
		return ""
	}

	var parts []string
	parts = append(parts, "-- Enums auto-generated by flash pull\n")
	for _, enum := range enums {
		values := make([]string, len(enum.Values))
		for i, v := range enum.Values {
			values[i] = fmt.Sprintf("'%s'", v)
		}
		parts = append(parts, fmt.Sprintf("CREATE TYPE %s AS ENUM (%s);", enum.Name, strings.Join(values, ", ")))
	}
	return strings.Join(parts, "\n")
}
