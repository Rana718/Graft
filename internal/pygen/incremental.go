package pygen

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"

	"github.com/Lumos-Labs-HQ/flash/internal/gencommon"
	"github.com/Lumos-Labs-HQ/flash/internal/parser"
)

// generateQueriesIncremental generates Python queries with incremental support and parallel code generation
func (g *Generator) generateQueriesIncremental(queries []*parser.Query, fullRegen bool) error {
	queryGroups := make(map[string][]*parser.Query)
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries"
		}
		queryGroups[sourceFile] = append(queryGroups[sourceFile], query)
	}

	type fileGroup struct {
		sourceFile string
		queries    []*parser.Query
	}
	
	fileGroups := make([]fileGroup, 0, len(queryGroups))
	for sourceFile, fileQueries := range queryGroups {
		fileGroups = append(fileGroups, fileGroup{sourceFile, fileQueries})
	}

	usedNames := make(map[string]int)
	var usedNamesMu sync.Mutex

	numWorkers := runtime.NumCPU()
	if numWorkers > len(fileGroups) {
		numWorkers = len(fileGroups)
	}

	type generateResult struct {
		err error
	}

	workChan := make(chan fileGroup, len(fileGroups))
	resultChan := make(chan generateResult, len(fileGroups))

	var wg sync.WaitGroup
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for fg := range workChan {
				err := g.generateSinglePyFile(fg.sourceFile, fg.queries, fullRegen, &usedNamesMu, usedNames)
				resultChan <- generateResult{err: err}
			}
		}()
	}

	for _, fg := range fileGroups {
		workChan <- fg
	}
	close(workChan)

	go func() {
		wg.Wait()
		close(resultChan)
	}()

	for result := range resultChan {
		if result.err != nil {
			return result.err
		}
	}

	return nil
}

func (g *Generator) generateSinglePyFile(sourceFile string, fileQueries []*parser.Query, fullRegen bool, usedNamesMu *sync.Mutex, usedNames map[string]int) error {
	queryFile := filepath.Join(g.Config.Queries, sourceFile+".sql")
	currentHash, _ := gencommon.ComputeFileChecksum(queryFile)

	if !gencommon.ShouldRegenerateFile(g.cache, queryFile, currentHash, fullRegen) {
		gencommon.PrintSkipMessage(sourceFile, ".py")
		return nil
	}

	gencommon.PrintGenerateMessage(sourceFile, ".py")
	
	w := gencommon.GetBuilder()
	defer gencommon.PutBuilder(w)

	w.WriteString("# Code generated by FlashORM. DO NOT EDIT.\n\n")
	w.WriteString("from typing import Optional, List, Any\n")
	w.WriteString("from dataclasses import dataclass\n\n")

	for _, query := range fileQueries {
		if g.needsResultClass(query) {
			g.generateResultClass(w, query)
		}
	}

	w.WriteString("class Queries:\n")
	w.WriteString("    def __init__(self, db):\n")
	w.WriteString("        self.db = db\n")
	w.WriteString("        self._stmts = {}\n\n")

	for _, query := range fileQueries {
		g.generateQueryMethod(w, query)
	}

	baseName := strings.TrimSuffix(sourceFile, ".sql")

	usedNamesMu.Lock()
	outputFile := baseName + ".py"
	if count, exists := usedNames[baseName]; exists {
		usedNames[baseName] = count + 1
		outputFile = fmt.Sprintf("%s_%d.py", baseName, count+1)
	} else {
		usedNames[baseName] = 1
	}
	usedNamesMu.Unlock()

	path := filepath.Join(g.Config.Gen.Python.Out, outputFile)
	if err := os.WriteFile(path, []byte(w.String()), 0644); err != nil {
		return err
	}

	tableDeps := gencommon.ExtractTableDependencies(fileQueries)
	gencommon.UpdateCacheForFile(g.cache, queryFile, currentHash, tableDeps, path)

	return nil
}
