package pygen

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/Lumos-Labs-HQ/flash/internal/config"
	"github.com/Lumos-Labs-HQ/flash/internal/parser"
	"github.com/Lumos-Labs-HQ/flash/internal/utils"
)

type Generator struct {
	Config       *config.Config
	schema       *parser.Schema
	schemaParser *parser.SchemaParser
	queryParser  *parser.QueryParser
}

func New(cfg *config.Config) *Generator {
	return &Generator{
		Config:       cfg,
		schemaParser: parser.NewSchemaParser(cfg),
		queryParser:  parser.NewQueryParser(cfg),
	}
}

func (g *Generator) Generate() error {
	if err := os.MkdirAll(g.Config.Gen.Python.Out, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	schema, err := g.schemaParser.Parse()
	if err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}
	g.schema = schema

	queries, err := g.queryParser.Parse(schema)
	if err != nil {
		return fmt.Errorf("failed to parse queries: %w", err)
	}

	if err := g.generateModels(schema); err != nil {
		return err
	}

	if err := g.generateQueries(queries); err != nil {
		return err
	}

	if err := g.generateDatabase(); err != nil {
		return err
	}

	return g.generateInit()
}

func (g *Generator) generateModels(schema *parser.Schema) error {
	var w strings.Builder
	w.WriteString("# Code generated by Graft. DO NOT EDIT.\n\n")
	w.WriteString("from dataclasses import dataclass\n")
	w.WriteString("from typing import Optional\n")
	w.WriteString("from datetime import datetime\n\n")

	for _, table := range schema.Tables {
		w.WriteString("@dataclass\n")
		w.WriteString(fmt.Sprintf("class %s:\n", utils.Capitalize(table.Name)))
		for _, col := range table.Columns {
			pyType := g.sqlTypeToPython(col.Type, col.Nullable)
			w.WriteString(fmt.Sprintf("    %s: %s\n", col.Name, pyType))
		}
		w.WriteString("\n")
	}

	path := filepath.Join(g.Config.Gen.Python.Out, "models.py")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) generateQueries(queries []*parser.Query) error {
	queryGroups := make(map[string][]*parser.Query)
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries"
		}
		queryGroups[sourceFile] = append(queryGroups[sourceFile], query)
	}

	for sourceFile, fileQueries := range queryGroups {
		var w strings.Builder
		w.WriteString("# Code generated by Graft. DO NOT EDIT.\n\n")
		w.WriteString("from dataclasses import dataclass\n")
		w.WriteString("from typing import Optional, List, Any\n")
		w.WriteString("from datetime import datetime\n\n")

		// Generate result types for queries with multiple columns
		for _, query := range fileQueries {
			if g.needsResultClass(query) {
				g.generateResultClass(&w, query)
			}
		}

		w.WriteString("class Queries:\n")
		w.WriteString("    def __init__(self, db):\n")
		w.WriteString("        self.db = db\n")
		w.WriteString("        self._stmts = {}\n\n")

		for _, query := range fileQueries {
			g.generateQueryMethod(&w, query)
		}

		baseName := strings.TrimSuffix(sourceFile, ".sql")
		outputFile := baseName + ".py"
		path := filepath.Join(g.Config.Gen.Python.Out, outputFile)
		if err := os.WriteFile(path, []byte(w.String()), 0644); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) generateQueryMethod(w *strings.Builder, query *parser.Query) {
	methodName := utils.ToSnakeCase(query.Name)
	sql := g.convertSQL(query.SQL)
	sql = strings.ReplaceAll(sql, "\"", "\\\"")

	paramNames := make([]string, len(query.Params))
	paramTypes := make([]string, len(query.Params))
	for i, param := range query.Params {
		paramName := param.Name
		if paramName == "" {
			paramName = fmt.Sprintf("p%d", i+1)
		}
		paramNames[i] = paramName
		paramTypes[i] = fmt.Sprintf("%s: %s", paramName, g.sqlTypeToPython(param.Type, false))
	}

	returnType := g.getReturnType(query)
	w.WriteString(fmt.Sprintf("    async def %s(self, %s) -> %s:\n",
		methodName, strings.Join(paramTypes, ", "), returnType))
	w.WriteString(fmt.Sprintf("        stmt = \"\"\"%s\"\"\"\n", sql))

	provider := g.Config.Database.Provider
	switch provider {
	case "sqlite", "sqlite3":
		g.generateSQLiteExecution(w, paramNames, query)
	case "mysql":
		g.generateMySQLExecution(w, paramNames, query)
	default:
		g.generatePostgreSQLExecution(w, paramNames, query)
	}

	w.WriteString("\n")
}

func (g *Generator) generatePostgreSQLExecution(w *strings.Builder, paramNames []string, query *parser.Query) {
	hasColumns := len(query.Columns) > 0
	isSingleColumn := len(query.Columns) == 1

	if len(paramNames) > 0 {
		w.WriteString(fmt.Sprintf("        result = await self.db.fetch(stmt, %s)\n", strings.Join(paramNames, ", ")))
	} else {
		w.WriteString("        result = await self.db.fetch(stmt)\n")
	}

	isSingleNonWildcard := isSingleColumn && query.Columns[0].Name != "*"
	needsResultClass := g.needsResultClass(query)

	if hasColumns {
		if query.Cmd == ":one" {
			if isSingleNonWildcard {
				w.WriteString(fmt.Sprintf("        return result[0]['%s'] if result else None\n", query.Columns[0].Name))
			} else if needsResultClass {
				className := utils.ToPascalCase(query.Name) + "Row"
				w.WriteString(fmt.Sprintf("        return %s(**dict(result[0])) if result else None\n", className))
			} else {
				w.WriteString("        return dict(result[0]) if result else None\n")
			}
		} else {
			if isSingleNonWildcard {
				w.WriteString(fmt.Sprintf("        return [row['%s'] for row in result]\n", query.Columns[0].Name))
			} else if needsResultClass {
				className := utils.ToPascalCase(query.Name) + "Row"
				w.WriteString(fmt.Sprintf("        return [%s(**dict(row)) for row in result]\n", className))
			} else {
				w.WriteString("        return [dict(row) for row in result]\n")
			}
		}
	} else {
		switch query.Cmd {
		case ":one":
			w.WriteString("        return dict(result[0]) if result else None\n")
		case ":many":
			w.WriteString("        return [dict(row) for row in result]\n")
		default:
			w.WriteString("        return len(result)\n")
		}
	}
}

func (g *Generator) generateMySQLExecution(w *strings.Builder, paramNames []string, query *parser.Query) {
	w.WriteString("        async with self.db.cursor() as cursor:\n")
	if len(paramNames) > 0 {
		w.WriteString(fmt.Sprintf("            await cursor.execute(stmt, (%s,))\n", strings.Join(paramNames, ", ")))
	} else {
		w.WriteString("            await cursor.execute(stmt)\n")
	}

	switch query.Cmd {
	case ":one":
		w.WriteString("            result = await cursor.fetchone()\n")
		w.WriteString("            return dict(result) if result else None\n")
	case ":many":
		w.WriteString("            result = await cursor.fetchall()\n")
		w.WriteString("            return [dict(row) for row in result]\n")
	default:
		w.WriteString("            return cursor.rowcount\n")
	}
}

func (g *Generator) generateSQLiteExecution(w *strings.Builder, paramNames []string, query *parser.Query) {
	w.WriteString("        async with self.db.execute(stmt")
	if len(paramNames) > 0 {
		w.WriteString(fmt.Sprintf(", (%s,)", strings.Join(paramNames, ", ")))
	}
	w.WriteString(") as cursor:\n")

	switch query.Cmd {
	case ":one":
		w.WriteString("            result = await cursor.fetchone()\n")
		w.WriteString("            return dict(result) if result else None\n")
	case ":many":
		w.WriteString("            result = await cursor.fetchall()\n")
		w.WriteString("            return [dict(row) for row in result]\n")
	default:
		w.WriteString("            return cursor.rowcount\n")
	}
}

func (g *Generator) generateDatabase() error {
	var w strings.Builder
	w.WriteString("# Code generated by Graft. DO NOT EDIT.\n\n")

	provider := g.Config.Database.Provider
	switch provider {
	case "sqlite", "sqlite3":
		w.WriteString("import aiosqlite\n\n")
		w.WriteString("async def connect(database_url: str):\n")
		w.WriteString("    return await aiosqlite.connect(database_url.replace('sqlite://', ''))\n")
	case "mysql":
		w.WriteString("import aiomysql\n\n")
		w.WriteString("async def connect(database_url: str):\n")
		w.WriteString("    return await aiomysql.connect(host='localhost', user='root', db='test')\n")
	default:
		w.WriteString("import asyncpg\n\n")
		w.WriteString("async def connect(database_url: str):\n")
		w.WriteString("    return await asyncpg.connect(database_url)\n")
	}

	path := filepath.Join(g.Config.Gen.Python.Out, "database.py")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) generateInit() error {
	var w strings.Builder
	w.WriteString("# Code generated by Graft. DO NOT EDIT.\n\n")
	w.WriteString("from .database import connect\n")
	w.WriteString("from .models import *\n")

	path := filepath.Join(g.Config.Gen.Python.Out, "__init__.py")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) convertSQL(sql string) string {
	provider := g.Config.Database.Provider
	if provider == "mysql" {
		for i := 1; i <= 20; i++ {
			sql = strings.ReplaceAll(sql, fmt.Sprintf("$%d", i), "?")
		}
	}
	return sql
}

func (g *Generator) sqlTypeToPython(sqlType string, nullable bool) string {
	sqlType = strings.ToLower(sqlType)
	var pyType string

	switch {
	case strings.Contains(sqlType, "int"), strings.Contains(sqlType, "serial"):
		pyType = "int"
	case strings.Contains(sqlType, "float"), strings.Contains(sqlType, "double"), strings.Contains(sqlType, "decimal"):
		pyType = "float"
	case strings.Contains(sqlType, "bool"):
		pyType = "bool"
	case strings.Contains(sqlType, "timestamp"), strings.Contains(sqlType, "date"), strings.Contains(sqlType, "time"):
		pyType = "datetime"
	default:
		pyType = "str"
	}

	if nullable {
		return fmt.Sprintf("Optional[%s]", pyType)
	}
	return pyType
}

func (g *Generator) needsResultClass(query *parser.Query) bool {
	// Generate result class for queries that return multiple columns or SELECT *
	if len(query.Columns) == 0 {
		return false
	}

	// Single column that's not * doesn't need a class
	if len(query.Columns) == 1 && query.Columns[0].Name != "*" {
		return false
	}

	return true
}

func (g *Generator) generateResultClass(w *strings.Builder, query *parser.Query) {
	className := utils.ToPascalCase(query.Name) + "Row"

	// Expand wildcard columns
	columns := g.expandWildcardColumns(query)
	if len(columns) == 0 {
		return
	}

	w.WriteString("@dataclass\n")
	w.WriteString(fmt.Sprintf("class %s:\n", className))
	for _, col := range columns {
		pyType := g.sqlTypeToPython(col.Type, col.Nullable)
		w.WriteString(fmt.Sprintf("    %s: %s\n", utils.ToSnakeCase(col.Name), pyType))
	}
	w.WriteString("\n")
}

func (g *Generator) expandWildcardColumns(query *parser.Query) []*parser.QueryColumn {
	// If we have specific columns (not just *), return them
	if len(query.Columns) > 1 {
		return query.Columns
	}

	if len(query.Columns) == 1 && query.Columns[0].Name != "*" {
		return query.Columns
	}

	// Find the table being queried
	tableName := g.extractTableName(query.SQL)
	if tableName == "" {
		return query.Columns
	}

	// Find table in schema
	var table *parser.Table
	for _, t := range g.schema.Tables {
		if strings.EqualFold(t.Name, tableName) {
			table = t
			break
		}
	}

	if table == nil {
		return query.Columns
	}

	// Expand * to all columns
	expanded := make([]*parser.QueryColumn, 0, len(table.Columns))
	for _, col := range table.Columns {
		expanded = append(expanded, &parser.QueryColumn{
			Name:     col.Name,
			Type:     col.Type,
			Table:    table.Name,
			Nullable: col.Nullable,
		})
	}

	return expanded
}

func (g *Generator) extractTableName(sql string) string {
	// Try INSERT INTO
	insertRegex := regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`)
	if matches := insertRegex.FindStringSubmatch(sql); len(matches) > 1 {
		return matches[1]
	}

	// Try FROM
	fromRegex := regexp.MustCompile(`(?i)FROM\s+(\w+)`)
	if matches := fromRegex.FindStringSubmatch(sql); len(matches) > 1 {
		return matches[1]
	}

	// Try UPDATE
	updateRegex := regexp.MustCompile(`(?i)UPDATE\s+(\w+)`)
	if matches := updateRegex.FindStringSubmatch(sql); len(matches) > 1 {
		return matches[1]
	}

	return ""
}

func (g *Generator) getReturnType(query *parser.Query) string {
	hasColumns := len(query.Columns) > 0
	isSingleColumn := len(query.Columns) == 1 && query.Columns[0].Name != "*"

	// Single non-wildcard column
	if hasColumns && isSingleColumn {
		pyType := g.sqlTypeToPython(query.Columns[0].Type, false)
		if query.Cmd == ":one" {
			return fmt.Sprintf("Optional[%s]", pyType)
		}
		return fmt.Sprintf("List[%s]", pyType)
	}

	// Multiple columns or wildcard - use result class
	if g.needsResultClass(query) {
		className := utils.ToPascalCase(query.Name) + "Row"
		if query.Cmd == ":one" {
			return fmt.Sprintf("Optional[%s]", className)
		}
		return fmt.Sprintf("List[%s]", className)
	}

	// Fallback for exec queries
	switch query.Cmd {
	case ":one":
		return "Optional[dict]"
	case ":many":
		return "List[dict]"
	}
	return "int"
}
