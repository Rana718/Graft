package pygen

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/Lumos-Labs-HQ/flash/internal/config"
	"github.com/Lumos-Labs-HQ/flash/internal/parser"
	"github.com/Lumos-Labs-HQ/flash/internal/utils"
)

type Generator struct {
	Config       *config.Config
	schema       *parser.Schema
	schemaParser *parser.SchemaParser
	queryParser  *parser.QueryParser
}

func New(cfg *config.Config) *Generator {
	return &Generator{
		Config:       cfg,
		schemaParser: parser.NewSchemaParser(cfg),
		queryParser:  parser.NewQueryParser(cfg),
	}
}

func (g *Generator) Generate() error {
	if err := os.MkdirAll(g.Config.Gen.Python.Out, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	schema, err := g.schemaParser.Parse()
	if err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}
	g.schema = schema

	queries, err := g.queryParser.Parse(schema)
	if err != nil {
		return fmt.Errorf("failed to parse queries: %w", err)
	}

	if err := g.generateModels(schema); err != nil {
		return err
	}

	if err := g.generateQueries(queries); err != nil {
		return err
	}

	if err := g.generateDatabase(queries); err != nil {
		return err
	}

	return g.generateInit()
}

func (g *Generator) generateModels(schema *parser.Schema) error {
	var w strings.Builder
	// Pre-allocate: header + ~150 bytes per table
	estimatedSize := 200 + (len(schema.Tables) * 150)
	w.Grow(estimatedSize)
	w.WriteString("# Code generated by FlashORM. DO NOT EDIT.\n\n")
	w.WriteString("from dataclasses import dataclass\n")
	w.WriteString("from typing import Optional, Literal\n")
	w.WriteString("from datetime import datetime\n")
	w.WriteString("from decimal import Decimal\n\n")

	for _, table := range schema.Tables {
		w.WriteString("@dataclass\n")
		w.WriteString(fmt.Sprintf("class %s:\n", utils.Capitalize(table.Name)))
		for _, col := range table.Columns {
			pyType := g.sqlTypeToPython(col.Type, col.Nullable)
			w.WriteString(fmt.Sprintf("    %s: %s\n", col.Name, pyType))
		}
		w.WriteString("\n")
	}

	path := filepath.Join(g.Config.Gen.Python.Out, "models.py")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) generateQueries(queries []*parser.Query) error {
	queryGroups := make(map[string][]*parser.Query)
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries"
		}
		queryGroups[sourceFile] = append(queryGroups[sourceFile], query)
	}

	for sourceFile, fileQueries := range queryGroups {
		var w strings.Builder
		// Pre-allocate: header + ~400 bytes per query
		estimatedSize := 200 + (len(fileQueries) * 400)
		w.Grow(estimatedSize)
		w.WriteString("# Code generated by FlashORM. DO NOT EDIT.\n\n")
		w.WriteString("from dataclasses import dataclass\n")
		w.WriteString("from typing import Optional, List, Any, Literal\n")
		w.WriteString("from datetime import datetime\n")
		w.WriteString("from decimal import Decimal\n\n")

		for _, query := range fileQueries {
			if g.needsResultClass(query) {
				g.generateResultClass(&w, query)
			}
		}

		w.WriteString("class Queries:\n")
		w.WriteString("    def __init__(self, db):\n")
		w.WriteString("        self.db = db\n")
		w.WriteString("        self._stmts = {}\n\n")

		for _, query := range fileQueries {
			g.generateQueryMethod(&w, query)
			if query.Cmd == ":exec" && strings.Contains(strings.ToUpper(query.SQL), "INSERT INTO") {
				g.generateBatchMethod(&w, query)
			}
		}

		baseName := strings.TrimSuffix(sourceFile, ".sql")
		outputFile := baseName + ".py"
		path := filepath.Join(g.Config.Gen.Python.Out, outputFile)
		if err := os.WriteFile(path, []byte(w.String()), 0644); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) generateQueryMethod(w *strings.Builder, query *parser.Query) {
	methodName := utils.ToSnakeCase(query.Name)
	sql := g.convertSQL(query.SQL)
	sql = strings.ReplaceAll(sql, "\"", "\\\"")

	paramNames := make([]string, len(query.Params))
	paramTypes := make([]string, len(query.Params))
	for i, param := range query.Params {
		paramName := param.Name
		if paramName == "" {
			paramName = fmt.Sprintf("p%d", i+1)
		}
		paramNames[i] = paramName
		paramTypes[i] = fmt.Sprintf("%s: %s", paramName, g.sqlTypeToPython(param.Type, false))
	}

	returnType := g.getReturnType(query)
	w.WriteString(fmt.Sprintf("    async def %s(self, %s) -> %s:\n",
		methodName, strings.Join(paramTypes, ", "), returnType))
	w.WriteString(fmt.Sprintf("        stmt = \"\"\"%s\"\"\"\n", sql))

	provider := g.Config.Database.Provider
	switch provider {
	case "sqlite", "sqlite3":
		g.generateSQLiteExecution(w, paramNames, query)
	case "mysql":
		g.generateMySQLExecution(w, paramNames, query)
	default:
		g.generatePostgreSQLExecution(w, paramNames, query)
	}

	w.WriteString("\n")
}

func (g *Generator) generatePostgreSQLExecution(w *strings.Builder, paramNames []string, query *parser.Query) {
	hasColumns := len(query.Columns) > 0
	isSingleColumn := len(query.Columns) == 1

	if query.Cmd == ":exec" {
		if len(paramNames) > 0 {
			w.WriteString(fmt.Sprintf("        await self.db.execute(stmt, %s)\n", strings.Join(paramNames, ", ")))
		} else {
			w.WriteString("        await self.db.execute(stmt)\n")
		}
		w.WriteString("        return 1\n")
		return
	}

	if len(paramNames) > 0 {
		w.WriteString(fmt.Sprintf("        result = await self.db.fetch(stmt, %s)\n", strings.Join(paramNames, ", ")))
	} else {
		w.WriteString("        result = await self.db.fetch(stmt)\n")
	}

	isSingleNonWildcard := isSingleColumn && query.Columns[0].Name != "*"
	needsResultClass := g.needsResultClass(query)

	if hasColumns {
		if query.Cmd == ":one" {
			if isSingleNonWildcard {
				w.WriteString(fmt.Sprintf("        return result[0]['%s'] if result else None\n", query.Columns[0].Name))
			} else if needsResultClass {
				className := utils.ToPascalCase(query.Name) + "Row"
				w.WriteString(fmt.Sprintf("        return %s._make_fast(result[0]) if result else None\n", className))
			} else {
				w.WriteString("        return dict(result[0]) if result else None\n")
			}
		} else {
			if isSingleNonWildcard {
				w.WriteString(fmt.Sprintf("        return [row['%s'] for row in result]\n", query.Columns[0].Name))
			} else if needsResultClass {
				className := utils.ToPascalCase(query.Name) + "Row"
				w.WriteString(fmt.Sprintf("        return [%s._make_fast(row) for row in result]\n", className))
			} else {
				w.WriteString("        return [dict(row) for row in result]\n")
			}
		}
	} else {
		switch query.Cmd {
		case ":one":
			w.WriteString("        return dict(result[0]) if result else None\n")
		case ":many":
			w.WriteString("        return [dict(row) for row in result]\n")
		default:
			w.WriteString("        return len(result)\n")
		}
	}
}

func (g *Generator) generateMySQLExecution(w *strings.Builder, paramNames []string, query *parser.Query) {
	w.WriteString("        async with self.db.cursor() as cursor:\n")
	if len(paramNames) > 0 {
		w.WriteString(fmt.Sprintf("            await cursor.execute(stmt, (%s,))\n", strings.Join(paramNames, ", ")))
	} else {
		w.WriteString("            await cursor.execute(stmt)\n")
	}

	switch query.Cmd {
	case ":one":
		w.WriteString("            result = await cursor.fetchone()\n")
		w.WriteString("            return dict(result) if result else None\n")
	case ":many":
		w.WriteString("            result = await cursor.fetchall()\n")
		w.WriteString("            return [dict(row) for row in result]\n")
	default:
		w.WriteString("            return cursor.rowcount\n")
	}
}

func (g *Generator) generateSQLiteExecution(w *strings.Builder, paramNames []string, query *parser.Query) {
	w.WriteString("        async with self.db.execute(stmt")
	if len(paramNames) > 0 {
		w.WriteString(fmt.Sprintf(", (%s,)", strings.Join(paramNames, ", ")))
	}
	w.WriteString(") as cursor:\n")

	switch query.Cmd {
	case ":one":
		w.WriteString("            result = await cursor.fetchone()\n")
		w.WriteString("            return dict(result) if result else None\n")
	case ":many":
		w.WriteString("            result = await cursor.fetchall()\n")
		w.WriteString("            return [dict(row) for row in result]\n")
	default:
		w.WriteString("            return cursor.rowcount\n")
	}
}

func (g *Generator) generateDatabase(queries []*parser.Query) error {
	// Get unique source files
	sourceFiles := make(map[string]bool)
	filesList := []string{}
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries"
		}
		baseName := strings.TrimSuffix(sourceFile, ".sql")
		if !sourceFiles[baseName] {
			sourceFiles[baseName] = true
			filesList = append(filesList, baseName)
		}
	}

	var w strings.Builder
	w.Grow(512) // Pre-allocate for index file
	w.WriteString("# Code generated by FlashORM. DO NOT EDIT.\n")

	if len(filesList) == 1 {
		w.WriteString(fmt.Sprintf("from .%s import Queries\n\n", filesList[0]))
	} else {
		for _, baseName := range filesList {
			w.WriteString(fmt.Sprintf("from .%s import Queries as %sQueries\n",
				baseName, utils.Capitalize(baseName)))
		}
		w.WriteString("\n")

		w.WriteString("# Combine all query classes into one\n")
		w.WriteString("class Queries:\n")
		w.WriteString("    \"\"\"Unified query interface that delegates to individual query modules.\"\"\"\n")
		w.WriteString("    \n")
		w.WriteString("    def __init__(self, db):\n")
		w.WriteString("        self.db = db\n")

		for _, baseName := range filesList {
			className := utils.Capitalize(baseName)
			instanceName := fmt.Sprintf("_%s", baseName)
			w.WriteString(fmt.Sprintf("        self.%s = %sQueries(db)\n", instanceName, className))
		}

		w.WriteString("\n")
		w.WriteString("    def __getattr__(self, name):\n")
		w.WriteString("        \"\"\"Delegate attribute access to query modules.\"\"\"\n")

		for i, baseName := range filesList {
			instanceName := fmt.Sprintf("_%s", baseName)
			if i == 0 {
				w.WriteString(fmt.Sprintf("        if hasattr(self.%s, name):\n", instanceName))
				w.WriteString(fmt.Sprintf("            return getattr(self.%s, name)\n", instanceName))
			} else {
				w.WriteString(fmt.Sprintf("        elif hasattr(self.%s, name):\n", instanceName))
				w.WriteString(fmt.Sprintf("            return getattr(self.%s, name)\n", instanceName))
			}
		}

		w.WriteString("        raise AttributeError(f\"'{type(self).__name__}' object has no attribute '{name}'\")\n")
	}

	w.WriteString("\ndef new(db):\n")
	w.WriteString("    \"\"\"\n")
	w.WriteString("    Create a new database client.\n")
	w.WriteString("    \n")
	w.WriteString("    Args:\n")
	w.WriteString("        db: Database connection (asyncpg.Pool, aiomysql.Pool, or aiosqlite connection)\n")
	w.WriteString("    \n")
	w.WriteString("    Returns:\n")
	w.WriteString("        Queries: An instance of the Queries class\n")
	w.WriteString("    \"\"\"\n")
	w.WriteString("    return Queries(db)\n")

	path := filepath.Join(g.Config.Gen.Python.Out, "database.py")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) generateInit() error {
	var w strings.Builder
	w.Grow(256) // Pre-allocate small buffer
	w.WriteString("# Code generated by FlashORM. DO NOT EDIT.\n\n")
	w.WriteString("from .database import new\n")
	w.WriteString("from .models import *\n")

	path := filepath.Join(g.Config.Gen.Python.Out, "__init__.py")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) convertSQL(sql string) string {
	provider := g.Config.Database.Provider
	if provider == "mysql" {
		for i := 1; i <= 20; i++ {
			sql = strings.ReplaceAll(sql, fmt.Sprintf("$%d", i), "?")
		}
	}
	return sql
}

func (g *Generator) sqlTypeToPython(sqlType string, nullable bool) string {
	sqlTypeLower := strings.ToLower(sqlType)
	var pyType string

	// Check for enum types 
	if g.schema != nil {
		for _, enum := range g.schema.Enums {
			if strings.ToLower(enum.Name) == sqlTypeLower {
				quotedValues := make([]string, len(enum.Values))
				for i, v := range enum.Values {
					quotedValues[i] = fmt.Sprintf("'%s'", v)
				}
				pyType = fmt.Sprintf("Literal[%s]", strings.Join(quotedValues, ", "))
				if nullable {
					return fmt.Sprintf("Optional[%s]", pyType)
				}
				return pyType
			}
		}
	}

	switch {
	case strings.Contains(sqlTypeLower, "[]"): // Array type
		if strings.Contains(sqlTypeLower, "int") {
			pyType = "List[int]"
		} else {
			pyType = "List[str]"
		}
	case strings.Contains(sqlTypeLower, "bigint"), strings.Contains(sqlTypeLower, "int8"):
		pyType = "int"
	case strings.Contains(sqlTypeLower, "int"), strings.Contains(sqlTypeLower, "serial"), strings.Contains(sqlTypeLower, "smallint"):
		pyType = "int"
	case strings.Contains(sqlTypeLower, "numeric"), strings.Contains(sqlTypeLower, "decimal"):
		pyType = "Decimal"
	case strings.Contains(sqlTypeLower, "float"), strings.Contains(sqlTypeLower, "double"), strings.Contains(sqlTypeLower, "real"):
		pyType = "float"
	case strings.Contains(sqlTypeLower, "bool"):
		pyType = "bool"
	case strings.Contains(sqlTypeLower, "timestamp"), strings.Contains(sqlTypeLower, "date"):
		pyType = "datetime"
	case strings.Contains(sqlTypeLower, "time") && !strings.Contains(sqlTypeLower, "timestamp"):
		pyType = "datetime"
	case strings.Contains(sqlTypeLower, "json"):
		pyType = "dict"
	default:
		pyType = "str"
	}

	if nullable {
		return fmt.Sprintf("Optional[%s]", pyType)
	}
	return pyType
}

func (g *Generator) needsResultClass(query *parser.Query) bool {
	if len(query.Columns) == 0 {
		return false
	}

	if len(query.Columns) == 1 && query.Columns[0].Name != "*" {
		return false
	}

	return true
}

func (g *Generator) generateResultClass(w *strings.Builder, query *parser.Query) {
	className := utils.ToPascalCase(query.Name) + "Row"

	columns := g.expandWildcardColumns(query)
	if len(columns) == 0 {
		return
	}

	w.WriteString("@dataclass\n")
	w.WriteString(fmt.Sprintf("class %s:\n", className))
	for _, col := range columns {
		pyType := g.sqlTypeToPython(col.Type, col.Nullable)
		w.WriteString(fmt.Sprintf("    %s: %s\n", utils.ToSnakeCase(col.Name), pyType))
	}

	// Add optimized factory method for faster Record -> dataclass conversion
	w.WriteString("\n")
	w.WriteString("    @classmethod\n")
	w.WriteString("    def _make_fast(cls, record):\n")
	w.WriteString("        \"\"\"Optimized factory: 2-3x faster than **dict(record)\"\"\"\n")
	w.WriteString("        return cls(\n")
	for i, col := range columns {
		colName := utils.ToSnakeCase(col.Name)
		if i < len(columns)-1 {
			w.WriteString(fmt.Sprintf("            record['%s'],\n", colName))
		} else {
			w.WriteString(fmt.Sprintf("            record['%s']\n", colName))
		}
	}
	w.WriteString("        )\n")
	w.WriteString("\n")
}

func (g *Generator) expandWildcardColumns(query *parser.Query) []*parser.QueryColumn {
	if len(query.Columns) > 1 {
		return query.Columns
	}

	if len(query.Columns) == 1 && query.Columns[0].Name != "*" {
		return query.Columns
	}

	tableName := g.extractTableName(query.SQL)
	if tableName == "" {
		return query.Columns
	}

	var table *parser.Table
	for _, t := range g.schema.Tables {
		if strings.EqualFold(t.Name, tableName) {
			table = t
			break
		}
	}

	if table == nil {
		return query.Columns
	}

	expanded := make([]*parser.QueryColumn, 0, len(table.Columns))
	for _, col := range table.Columns {
		expanded = append(expanded, &parser.QueryColumn{
			Name:     col.Name,
			Type:     col.Type,
			Table:    table.Name,
			Nullable: col.Nullable,
		})
	}

	return expanded
}

func (g *Generator) extractTableName(sql string) string {

	insertRegex := regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`)
	if matches := insertRegex.FindStringSubmatch(sql); len(matches) > 1 {
		return matches[1]
	}

	fromRegex := regexp.MustCompile(`(?i)FROM\s+(\w+)`)
	if matches := fromRegex.FindStringSubmatch(sql); len(matches) > 1 {
		return matches[1]
	}

	updateRegex := regexp.MustCompile(`(?i)UPDATE\s+(\w+)`)
	if matches := updateRegex.FindStringSubmatch(sql); len(matches) > 1 {
		return matches[1]
	}

	return ""
}

func (g *Generator) getReturnType(query *parser.Query) string {
	hasColumns := len(query.Columns) > 0
	isSingleColumn := len(query.Columns) == 1 && query.Columns[0].Name != "*"

	if hasColumns && isSingleColumn {
		pyType := g.sqlTypeToPython(query.Columns[0].Type, false)
		if query.Cmd == ":one" {
			return fmt.Sprintf("Optional[%s]", pyType)
		}
		return fmt.Sprintf("List[%s]", pyType)
	}

	if g.needsResultClass(query) {
		className := utils.ToPascalCase(query.Name) + "Row"
		if query.Cmd == ":one" {
			return fmt.Sprintf("Optional[%s]", className)
		}
		return fmt.Sprintf("List[%s]", className)
	}

	switch query.Cmd {
	case ":one":
		return "Optional[dict]"
	case ":many":
		return "List[dict]"
	}
	return "int"
}

func (g *Generator) generateBatchMethod(w *strings.Builder, query *parser.Query) {
	methodName := utils.ToSnakeCase(query.Name) + "_batch"
	sql := g.convertSQL(query.SQL)
	sql = strings.ReplaceAll(sql, "\"", "\\\"")

	w.WriteString(fmt.Sprintf("    async def %s(self, records: List[tuple]) -> int:\n", methodName))
	w.WriteString(fmt.Sprintf("        \"\"\"Batch insert for %s. Each record should be a tuple of parameters.\"\"\"\n", query.Name))
	w.WriteString(fmt.Sprintf("        stmt = \"\"\"%s\"\"\"\n", sql))

	provider := g.Config.Database.Provider
	switch provider {
	case "sqlite", "sqlite3":
		w.WriteString("        async with self.db.execute_many(stmt, records) as cursor:\n")
		w.WriteString("            return cursor.rowcount\n")
	case "mysql":
		w.WriteString("        async with self.db.cursor() as cursor:\n")
		w.WriteString("            await cursor.executemany(stmt, records)\n")
		w.WriteString("            return cursor.rowcount\n")
	default: // PostgreSQL
		w.WriteString("        await self.db.executemany(stmt, records)\n")
		w.WriteString("        return len(records)\n")
	}

	w.WriteString("\n")
}
