package jsgen

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/Lumos-Labs-HQ/flash/internal/config"
	"github.com/Lumos-Labs-HQ/flash/internal/parser"
	"github.com/Lumos-Labs-HQ/flash/internal/utils"
)

type Generator struct {
	Config       *config.Config
	insertRegex  *regexp.Regexp
	updateRegex  *regexp.Regexp
	deleteRegex  *regexp.Regexp
	schema       *parser.Schema
	schemaParser *parser.SchemaParser
	queryParser  *parser.QueryParser
}

func New(cfg *config.Config) *Generator {
	return &Generator{
		Config:       cfg,
		insertRegex:  regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`),
		updateRegex:  regexp.MustCompile(`(?i)UPDATE\s+(\w+)`),
		deleteRegex:  regexp.MustCompile(`(?i)DELETE\s+FROM\s+(\w+)`),
		schemaParser: parser.NewSchemaParser(cfg),
		queryParser:  parser.NewQueryParser(cfg),
	}
}

func (g *Generator) Generate() error {
	if err := os.MkdirAll(g.Config.Gen.JS.Out, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	schema, err := g.schemaParser.Parse()
	if err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}
	g.schema = schema

	queries, err := g.queryParser.Parse(schema)
	if err != nil {
		return fmt.Errorf("failed to parse queries: %w", err)
	}

	if err := g.generateQueries(queries); err != nil {
		return err
	}

	if err := g.generateDatabase(queries); err != nil {
		return err
	}

	return g.generateTypeScriptDeclarations(schema, queries)
}

func (g *Generator) generateQueries(queries []*parser.Query) error {
	queryGroups := make(map[string][]*parser.Query)
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries"
		}
		queryGroups[sourceFile] = append(queryGroups[sourceFile], query)
	}

	usedNames := make(map[string]int)

	for sourceFile, fileQueries := range queryGroups {
		// Pre-allocate buffer: ~200 bytes header + ~400 bytes per query method
		estimatedSize := 200 + (len(fileQueries) * 400)
		var w strings.Builder
		w.Grow(estimatedSize)

		w.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n\n")

		w.WriteString("class Queries {\n")
		w.WriteString("  constructor(db) {\n")
		w.WriteString("    this.db = db;\n")
		w.WriteString("    this._stmts = new Map();\n")
		w.WriteString("  }\n\n")

		for _, query := range fileQueries {
			g.generateOptimizedQueryMethod(&w, query)
		}

		w.WriteString("}\n\nmodule.exports = { Queries };\n")

		baseName := strings.TrimSuffix(sourceFile, ".sql")
		outputFile := baseName + ".js"

		if count, exists := usedNames[baseName]; exists {
			usedNames[baseName] = count + 1
			outputFile = fmt.Sprintf("%s_%d.js", baseName, count+1)
		} else {
			usedNames[baseName] = 1
		}

		path := filepath.Join(g.Config.Gen.JS.Out, outputFile)
		if err := os.WriteFile(path, []byte(w.String()), 0644); err != nil {
			return err
		}
	}

	usedNames = make(map[string]int)

	for sourceFile := range queryGroups {
		// Pre-allocate buffer for TypeScript definitions
		var dts strings.Builder
		dts.Grow(100)

		dts.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n")
		dts.WriteString("export { Queries } from './index';\n")

		baseName := strings.TrimSuffix(sourceFile, ".sql")
		outputFile := baseName + ".d.ts"

		if count, exists := usedNames[baseName]; exists {
			usedNames[baseName] = count + 1
			outputFile = fmt.Sprintf("%s_%d.d.ts", baseName, count+1)
		} else {
			usedNames[baseName] = 1
		}
		dtsPath := filepath.Join(g.Config.Gen.JS.Out, outputFile)
		if err := os.WriteFile(dtsPath, []byte(dts.String()), 0644); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) generateOptimizedQueryMethod(w *strings.Builder, query *parser.Query) {
	methodName := utils.Uncapitalize(query.Name)
	sql := g.convertSQL(query.SQL)
	sql = strings.ReplaceAll(sql, "`", "\\`")
	sql = strings.ReplaceAll(sql, "${", "\\${")

	paramNames := make([]string, len(query.Params))
	for i, param := range query.Params {
		paramName := param.Name
		if paramName == "" {
			paramName = fmt.Sprintf("p%d", i+1)
		}
		paramNames[i] = paramName
	}

	hasColumns := len(query.Columns) > 0
	isSingleColumn := len(query.Columns) == 1 && query.Columns[0].Name != "*"
	isHotQuery := isSingleColumn && query.Cmd == ":one" && len(query.Params) <= 2

	w.WriteString(fmt.Sprintf("  async %s(%s) {\n", methodName, strings.Join(paramNames, ", ")))

	w.WriteString(fmt.Sprintf("    let stmt = this._stmts.get('%s');\n", methodName))
	w.WriteString("    if (!stmt) {\n")

	provider := g.Config.Database.Provider
	useNamedStmt := (provider == "" || provider == "postgresql" || provider == "postgres") &&
		(isHotQuery || len(query.Params) == 0)

	if useNamedStmt {
		w.WriteString(fmt.Sprintf("      stmt = { name: '%s', text: `%s` };\n", methodName, sql))
	} else {
		w.WriteString(fmt.Sprintf("      stmt = `%s`;\n", sql))
	}

	w.WriteString(fmt.Sprintf("      this._stmts.set('%s', stmt);\n", methodName))
	w.WriteString("    }\n")

	switch provider {
	case "sqlite", "sqlite3":
		g.generateSQLiteExecution(w, paramNames, hasColumns, query.Cmd, isSingleColumn, query.Columns)
	case "mysql":
		g.generateMySQLExecution(w, paramNames, hasColumns, query.Cmd, isSingleColumn, query.Columns)
	default:
		g.generatePostgreSQLExecution(w, paramNames, hasColumns, query.Cmd, isSingleColumn, query.Columns, isHotQuery)
	}

	w.WriteString("  }\n\n")
}

func (g *Generator) generatePostgreSQLExecution(w *strings.Builder, paramNames []string, hasColumns bool, cmd string, isSingleColumn bool, columns []*parser.QueryColumn, isHotQuery bool) {
	if len(paramNames) > 0 {
		if isHotQuery {
			w.WriteString("    stmt.values = [" + strings.Join(paramNames, ", ") + "];\n")
			w.WriteString("    const r = await this.db.query(stmt);\n")
		} else {
			w.WriteString("    const r = await this.db.query(stmt, [" + strings.Join(paramNames, ", ") + "]);\n")
		}
	} else {
		if isHotQuery {
			w.WriteString("    stmt.values = [];\n")
			w.WriteString("    const r = await this.db.query(stmt);\n")
		} else {
			w.WriteString("    const r = await this.db.query(stmt);\n")
		}
	}

	if hasColumns {
		if cmd == ":one" {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r.rows[0] ? r.rows[0].%s : null;\n", columns[0].Name))
			} else {
				w.WriteString("    return r.rows[0] || null;\n")
			}
		} else {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r.rows.map(row => row.%s);\n", columns[0].Name))
			} else {
				w.WriteString("    return r.rows;\n")
			}
		}
	} else {
		switch cmd {
		case ":one":
			w.WriteString("    return r.rows[0] || null;\n")
		case ":many":
			w.WriteString("    return r.rows;\n")
		default:
			w.WriteString("    return r.rowCount;\n")
		}
	}
}

func (g *Generator) generateMySQLExecution(w *strings.Builder, paramNames []string, hasColumns bool, cmd string, isSingleColumn bool, columns []*parser.QueryColumn) {
	w.WriteString("    const sql = typeof stmt === 'string' ? stmt : stmt.text;\n")
	if len(paramNames) > 0 {
		w.WriteString("    const r = await this.db.execute(sql, [" + strings.Join(paramNames, ", ") + "]);\n")
	} else {
		w.WriteString("    const r = await this.db.execute(sql);\n")
	}

	if hasColumns {
		if cmd == ":one" {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r[0][0] ? r[0][0].%s : null;\n", columns[0].Name))
			} else {
				w.WriteString("    return r[0][0] || null;\n")
			}
		} else {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r[0].map(row => row.%s);\n", columns[0].Name))
			} else {
				w.WriteString("    return r[0];\n")
			}
		}
	} else {
		w.WriteString("    return r[0].affectedRows;\n")
	}
}

func (g *Generator) generateSQLiteExecution(w *strings.Builder, paramNames []string, hasColumns bool, cmd string, isSingleColumn bool, columns []*parser.QueryColumn) {
	w.WriteString("    const sql = typeof stmt === 'string' ? stmt : stmt.text;\n")
	w.WriteString("    const prepared = this.db.prepare(sql);\n")

	if hasColumns {
		if cmd == ":one" {
			if len(paramNames) > 0 {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const row = prepared.get(" + strings.Join(paramNames, ", ") + ");\n")
					w.WriteString(fmt.Sprintf("    return row ? row.%s : null;\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.get(" + strings.Join(paramNames, ", ") + ") || null;\n")
				}
			} else {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const row = prepared.get();\n")
					w.WriteString(fmt.Sprintf("    return row ? row.%s : null;\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.get() || null;\n")
				}
			}
		} else {
			if len(paramNames) > 0 {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const rows = prepared.all(" + strings.Join(paramNames, ", ") + ");\n")
					w.WriteString(fmt.Sprintf("    return rows.map(row => row.%s);\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.all(" + strings.Join(paramNames, ", ") + ");\n")
				}
			} else {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const rows = prepared.all();\n")
					w.WriteString(fmt.Sprintf("    return rows.map(row => row.%s);\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.all();\n")
				}
			}
		}
	} else {
		if len(paramNames) > 0 {
			w.WriteString("    const info = prepared.run(" + strings.Join(paramNames, ", ") + ");\n")
		} else {
			w.WriteString("    const info = prepared.run();\n")
		}
		w.WriteString("    return info.changes;\n")
	}
}

func (g *Generator) getReturnType(query *parser.Query) string {
	if len(query.Columns) == 1 && query.Columns[0].Name != "*" {
		colName := strings.ToLower(query.Columns[0].Name)
		if colName == "count" || colName == "sum" || colName == "avg" ||
			colName == "max" || colName == "min" || colName == "total" ||
			strings.HasSuffix(colName, "_count") || strings.HasSuffix(colName, "_sum") ||
			strings.HasPrefix(colName, "avg_") || strings.HasPrefix(colName, "total_") {
			return "number"
		}

		if colName == "exists" || strings.HasPrefix(colName, "is") || strings.HasPrefix(colName, "has") {
			return "boolean"
		}

		if query.Columns[0].Table != "" && g.schema != nil {
			for _, table := range g.schema.Tables {
				if strings.EqualFold(table.Name, query.Columns[0].Table) {
					for _, col := range table.Columns {
						if strings.EqualFold(col.Name, query.Columns[0].Name) {
							return g.mapSQLTypeToJS(col.Type)
						}
					}
				}
			}
		}
		return "any"
	}

	if len(query.Columns) == 1 && query.Columns[0].Name == "*" && query.Columns[0].Table != "" {
		return utils.Capitalize(query.Columns[0].Table)
	}

	if len(query.Columns) > 1 {
		return "Object"
	}

	if match := g.insertRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return utils.Capitalize(match[1])
	}

	if match := g.updateRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return utils.Capitalize(match[1])
	}

	if match := g.deleteRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return utils.Capitalize(match[1])
	}

	return "Object"
}

func (g *Generator) generateDatabase(queries []*parser.Query) error {
	// Get unique source files
	sourceFiles := make(map[string]bool)
	filesList := []string{}
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries"
		}
		baseName := strings.TrimSuffix(sourceFile, ".sql")
		if !sourceFiles[baseName] {
			sourceFiles[baseName] = true
			filesList = append(filesList, baseName)
		}
	}

	var w strings.Builder
	w.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n")

	// If there's only one query file, just re-export it directly
	if len(filesList) == 1 {
		w.WriteString(fmt.Sprintf("const { Queries } = require('./%s');\n\n", filesList[0]))
	} else {
		// Multiple files: import and merge all query classes
		for _, baseName := range filesList {
			w.WriteString(fmt.Sprintf("const { Queries: %sQueries } = require('./%s');\n",
				utils.Capitalize(baseName), baseName))
		}
		w.WriteString("\n")

		w.WriteString("// Combine all query classes into one\n")
		w.WriteString("class Queries {\n")
		w.WriteString("  constructor(db) {\n")
		w.WriteString("    this.db = db;\n")

		// Instantiate each query class and copy methods to this instance
		for i, baseName := range filesList {
			className := utils.Capitalize(baseName)
			instanceName := fmt.Sprintf("_%s", baseName)
			w.WriteString(fmt.Sprintf("    const %s = new %sQueries(db);\n", instanceName, className))

			// Copy all methods from the instance to this
			w.WriteString(fmt.Sprintf("    Object.getOwnPropertyNames(Object.getPrototypeOf(%s)).forEach(name => {\n", instanceName))
			w.WriteString("      if (name !== 'constructor' && typeof " + instanceName + "[name] === 'function') {\n")
			w.WriteString("        this[name] = " + instanceName + "[name].bind(" + instanceName + ");\n")
			w.WriteString("      }\n")
			w.WriteString("    });\n")

			if i < len(filesList)-1 {
				w.WriteString("\n")
			}
		}

		w.WriteString("  }\n")
		w.WriteString("}\n\n")
	}

	w.WriteString("/**\n")
	w.WriteString(" * Create a new database client\n")
	w.WriteString(" * @param {Object} db - Database connection (pg.Pool, mysql2.Pool, or better-sqlite3 instance)\n")
	w.WriteString(" * @returns {Queries}\n")
	w.WriteString(" */\n")
	w.WriteString("function New(db) {\n")
	w.WriteString("  return new Queries(db);\n")
	w.WriteString("}\n\n")

	w.WriteString("module.exports = { New, Queries };\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "database.js")
	if err := os.WriteFile(path, []byte(w.String()), 0644); err != nil {
		return err
	}

	var dts strings.Builder
	dts.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n")
	dts.WriteString("export * from './index';\n")

	dtsPath := filepath.Join(g.Config.Gen.JS.Out, "database.d.ts")
	return os.WriteFile(dtsPath, []byte(dts.String()), 0644)
}

func (g *Generator) mapSQLTypeToJS(sqlType string) string {
	sqlTypeLower := strings.ToLower(sqlType)

	if g.schema != nil {
		for _, enum := range g.schema.Enums {
			if strings.ToLower(enum.Name) == sqlTypeLower {
				quotedValues := make([]string, len(enum.Values))
				for i, v := range enum.Values {
					quotedValues[i] = fmt.Sprintf("'%s'", v)
				}
				return strings.Join(quotedValues, " | ")
			}
		}
	}

	switch {
	case strings.Contains(sqlTypeLower, "int"), strings.Contains(sqlTypeLower, "serial"):
		return "number"
	case strings.Contains(sqlTypeLower, "numeric"), strings.Contains(sqlTypeLower, "decimal"), strings.Contains(sqlTypeLower, "float"), strings.Contains(sqlTypeLower, "double"), strings.Contains(sqlTypeLower, "real"):
		return "number"
	case strings.Contains(sqlTypeLower, "bool"):
		return "boolean"
	case strings.Contains(sqlTypeLower, "json"):
		return "Object"
	case strings.Contains(sqlTypeLower, "timestamp"), strings.Contains(sqlTypeLower, "date"), strings.Contains(sqlTypeLower, "time"):
		return "Date"
	case strings.Contains(sqlTypeLower, "bytea"), strings.Contains(sqlTypeLower, "blob"):
		return "Uint8Array"
	default:
		return "string"
	}
}

func (g *Generator) convertSQL(sql string) string {
	switch g.Config.Database.Provider {
	case "mysql", "sqlite", "sqlite3":
		result := sql
		for i := 20; i >= 1; i-- {
			result = strings.ReplaceAll(result, fmt.Sprintf("$%d", i), "?")
		}
		return result
	default:
		return sql
	}
}

func (g *Generator) generateTypeScriptDeclarations(schema *parser.Schema, queries []*parser.Query) error {
	var w strings.Builder
	w.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n\n")

	for _, table := range schema.Tables {
		structName := utils.Capitalize(table.Name)
		w.WriteString(fmt.Sprintf("export interface %s {\n", structName))
		for _, col := range table.Columns {
			jsType := g.mapSQLTypeToJS(col.Type)
			if col.Nullable {
				jsType += " | null"
			}
			w.WriteString(fmt.Sprintf("  %s: %s;\n", col.Name, jsType))
		}
		w.WriteString("}\n\n")
	}

	complexQueries := make(map[string]*parser.Query)
	for _, query := range queries {
		if len(query.Columns) > 1 && query.Cmd != ":exec" {
			complexQueries[query.Name] = query
		}
	}

	for queryName, query := range complexQueries {
		interfaceName := utils.Capitalize(queryName) + "Result"
		w.WriteString(fmt.Sprintf("export interface %s {\n", interfaceName))

		for _, col := range query.Columns {
			colType := g.inferColumnTypeFromSchema(col, query, schema)
			w.WriteString(fmt.Sprintf("  %s: %s;\n", col.Name, colType))
		}
		w.WriteString("}\n\n")
	}

	w.WriteString("export class Queries {\n")
	w.WriteString("  constructor(db: any);\n\n")

	seenMethods := make(map[string]bool)
	for _, query := range queries {
		methodName := utils.Uncapitalize(query.Name)

		if seenMethods[methodName] {
			continue
		}
		seenMethods[methodName] = true

		params := make([]string, len(query.Params))
		for i, param := range query.Params {
			paramName := param.Name
			if paramName == "" {
				paramName = fmt.Sprintf("p%d", i+1)
			}
			// Map SQL type to TypeScript type
			tsType := g.mapSQLTypeToJS(param.Type)
			params[i] = fmt.Sprintf("%s: %s", paramName, tsType)
		}

		returnType := g.getReturnType(query)

		if len(query.Columns) > 1 && query.Cmd != ":exec" {
			returnType = utils.Capitalize(query.Name) + "Result"
		}

		switch query.Cmd {
		case ":one":
			returnType = fmt.Sprintf("Promise<%s | null>", returnType)
		case ":many":
			returnType = fmt.Sprintf("Promise<%s[]>", returnType)
		default:
			returnType = "Promise<number>"
		}

		w.WriteString(fmt.Sprintf("  %s(%s): %s;\n", methodName, strings.Join(params, ", "), returnType))
	}

	w.WriteString("}\n\n")
	w.WriteString("export function New(db: any): Queries;\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "index.d.ts")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) inferColumnTypeFromSchema(col *parser.QueryColumn, query *parser.Query, schema *parser.Schema) string {
	colName := strings.ToLower(col.Name)

	if strings.Contains(colName, "count") || strings.Contains(colName, "total") ||
		strings.Contains(colName, "sum") {
		return "number"
	}
	if strings.Contains(colName, "avg") {
		return "number | null"
	}

	if col.Table != "" {
		for _, table := range schema.Tables {
			if strings.EqualFold(table.Name, col.Table) {
				for _, schemaCol := range table.Columns {
					if strings.EqualFold(schemaCol.Name, col.Name) {
						jsType := g.mapSQLTypeToJS(schemaCol.Type)
						if schemaCol.Nullable {
							jsType += " | null"
						}
						return jsType
					}
				}
			}
		}
	}

	tableAliases := g.extractTableAliases(query.SQL)

	for _, tableName := range tableAliases {
		for _, table := range schema.Tables {
			if strings.EqualFold(table.Name, tableName) {
				for _, schemaCol := range table.Columns {
					if strings.EqualFold(schemaCol.Name, col.Name) {
						jsType := g.mapSQLTypeToJS(schemaCol.Type)
						if schemaCol.Nullable {
							jsType += " | null"
						}
						return jsType
					}
				}
			}
		}
	}

	if strings.Contains(colName, "date") || strings.Contains(colName, "time") {
		return "Date"
	}
	if strings.Contains(colName, "id") || strings.HasSuffix(colName, "_id") {
		return "number"
	}
	if strings.Contains(colName, "is") || strings.Contains(colName, "has") {
		return "boolean"
	}

	return "string"
}

func (g *Generator) extractTableAliases(sql string) map[string]string {
	aliases := make(map[string]string)

	fromRe := regexp.MustCompile(`(?i)FROM\s+(\w+)\s+(\w+)`)
	if matches := fromRe.FindStringSubmatch(sql); len(matches) > 2 {
		aliases[matches[2]] = matches[1]
	}

	joinRe := regexp.MustCompile(`(?i)JOIN\s+(\w+)\s+(\w+)`)
	for _, matches := range joinRe.FindAllStringSubmatch(sql, -1) {
		if len(matches) > 2 {
			aliases[matches[2]] = matches[1]
		}
	}

	return aliases
}
