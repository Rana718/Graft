package jsgen

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/Rana718/Graft/internal/config"
)

type Generator struct {
	Config       *config.Config
	insertRegex  *regexp.Regexp
	updateRegex  *regexp.Regexp
	deleteRegex  *regexp.Regexp
	cachedSchema *Schema
}

func New(cfg *config.Config) *Generator {
	return &Generator{
		Config:      cfg,
		insertRegex: regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`),
		updateRegex: regexp.MustCompile(`(?i)UPDATE\s+(\w+)`),
		deleteRegex: regexp.MustCompile(`(?i)DELETE\s+FROM\s+(\w+)`),
	}
}

func (g *Generator) Generate() error {
	if err := os.MkdirAll(g.Config.Gen.JS.Out, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	schema, err := g.parseSchema()
	if err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}
	g.cachedSchema = schema

	queries, err := g.parseQueries()
	if err != nil {
		return fmt.Errorf("failed to parse queries: %w", err)
	}

	if err := g.generateTypes(schema); err != nil {
		return err
	}

	if err := g.generateQueries(queries); err != nil {
		return err
	}

	return g.generateDatabase()
}

func (g *Generator) generateTypes(schema *Schema) error {
	var w strings.Builder
	w.WriteString("// Code generated by Graft. DO NOT EDIT.\n\n")

	if len(schema.Tables) == 0 {
		w.WriteString("// No tables found in schema\n\n")
	}

	for _, table := range schema.Tables {
		structName := capitalize(table.Name)
		w.WriteString(fmt.Sprintf("/**\n * @typedef {Object} %s\n", structName))

		for _, col := range table.Columns {
			jsType := g.mapSQLTypeToJS(col.Type)
			nullable := ""
			if col.Nullable {
				nullable = "|null"
			}
			w.WriteString(fmt.Sprintf(" * @property {%s%s} %s\n", jsType, nullable, col.Name))
		}
		w.WriteString(" */\n\n")
	}

	w.WriteString("module.exports = {};\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "types.js")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) generateQueries(queries []*Query) error {
	var w strings.Builder
	w.WriteString("// Code generated by Graft. DO NOT EDIT.\n\n")

	w.WriteString("class Queries {\n")
	w.WriteString("  constructor(db) {\n")
	w.WriteString("    this.db = db;\n")
	w.WriteString("    this._stmts = new Map();\n")
	w.WriteString("  }\n\n")

	for _, query := range queries {
		g.generateOptimizedQueryMethod(&w, query)
	}

	w.WriteString("}\n\nmodule.exports = { Queries };\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "queries.js")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) generateOptimizedQueryMethod(w *strings.Builder, query *Query) {
	methodName := uncapitalize(query.Name)
	sql := g.convertSQL(query.SQL)
	sql = strings.ReplaceAll(sql, "`", "\\`")
	sql = strings.ReplaceAll(sql, "${", "\\${")

	w.WriteString("  /**\n")
	if query.Comment != "" {
		w.WriteString(fmt.Sprintf("   * %s\n", query.Comment))
	}

	paramNames := make([]string, len(query.Params))
	for i, param := range query.Params {
		paramName := param.Name
		if paramName == "" {
			paramName = fmt.Sprintf("p%d", i+1)
		}
		paramNames[i] = paramName
		w.WriteString(fmt.Sprintf("   * @param {%s} %s\n", param.Type, paramName))
	}

	returnType := g.getReturnType(query)
	hasColumns := len(query.Columns) > 0
	isSingleColumn := len(query.Columns) == 1 && query.Columns[0].Name != "*"

	isHotQuery := isSingleColumn && query.Cmd == ":one" && len(query.Params) <= 2

	switch query.Cmd {
	case ":one":
		w.WriteString(fmt.Sprintf("   * @returns {Promise<%s|null>}\n", returnType))
	case ":many":
		w.WriteString(fmt.Sprintf("   * @returns {Promise<%s[]>}\n", returnType))
	default:
		w.WriteString("   * @returns {Promise<number>}\n")
	}
	w.WriteString("   */\n")

	w.WriteString(fmt.Sprintf("  async %s(%s) {\n", methodName, strings.Join(paramNames, ", ")))

	w.WriteString(fmt.Sprintf("    let stmt = this._stmts.get('%s');\n", methodName))
	w.WriteString("    if (!stmt) {\n")

	provider := g.Config.Database.Provider
	useNamedStmt := (provider == "" || provider == "postgresql" || provider == "postgres") &&
		(isHotQuery || len(query.Params) == 0)

	if useNamedStmt {
		w.WriteString(fmt.Sprintf("      stmt = { name: '%s', text: `%s` };\n", methodName, sql))
	} else {
		w.WriteString(fmt.Sprintf("      stmt = `%s`;\n", sql))
	}

	w.WriteString(fmt.Sprintf("      this._stmts.set('%s', stmt);\n", methodName))
	w.WriteString("    }\n")

	switch provider {
	case "sqlite", "sqlite3":
		g.generateSQLiteExecution(w, paramNames, hasColumns, query.Cmd, isSingleColumn, query.Columns)
	case "mysql":
		g.generateMySQLExecution(w, paramNames, hasColumns, query.Cmd, isSingleColumn, query.Columns)
	default: // postgresql
		g.generatePostgreSQLExecution(w, paramNames, hasColumns, query.Cmd, isSingleColumn, query.Columns, isHotQuery)
	}

	w.WriteString("  }\n\n")
}

func (g *Generator) generatePostgreSQLExecution(w *strings.Builder, paramNames []string, hasColumns bool, cmd string, isSingleColumn bool, columns []*QueryColumn, isHotQuery bool) {
	if len(paramNames) > 0 {
		if isHotQuery {
			// Optimize: Reuse the prepared statement object instead of spreading
			w.WriteString("    stmt.values = [" + strings.Join(paramNames, ", ") + "];\n")
			w.WriteString("    const r = await this.db.query(stmt);\n")
		} else {
			w.WriteString("    const r = await this.db.query(stmt, [" + strings.Join(paramNames, ", ") + "]);\n")
		}
	} else {
		if isHotQuery {
			w.WriteString("    stmt.values = [];\n")
			w.WriteString("    const r = await this.db.query(stmt);\n")
		} else {
			w.WriteString("    const r = await this.db.query(stmt);\n")
		}
	}

	if hasColumns {
		if cmd == ":one" {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r.rows[0] ? r.rows[0].%s : null;\n", columns[0].Name))
			} else {
				w.WriteString("    return r.rows[0] || null;\n")
			}
		} else {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r.rows.map(row => row.%s);\n", columns[0].Name))
			} else {
				w.WriteString("    return r.rows;\n")
			}
		}
	} else {
		w.WriteString("    return r.rowCount;\n")
	}
}

func (g *Generator) generateMySQLExecution(w *strings.Builder, paramNames []string, hasColumns bool, cmd string, isSingleColumn bool, columns []*QueryColumn) {
	w.WriteString("    const sql = typeof stmt === 'string' ? stmt : stmt.text;\n")
	if len(paramNames) > 0 {
		w.WriteString("    const r = await this.db.execute(sql, [" + strings.Join(paramNames, ", ") + "]);\n")
	} else {
		w.WriteString("    const r = await this.db.execute(sql);\n")
	}

	if hasColumns {
		if cmd == ":one" {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r[0][0] ? r[0][0].%s : null;\n", columns[0].Name))
			} else {
				w.WriteString("    return r[0][0] || null;\n")
			}
		} else {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r[0].map(row => row.%s);\n", columns[0].Name))
			} else {
				w.WriteString("    return r[0];\n")
			}
		}
	} else {
		w.WriteString("    return r[0].affectedRows;\n")
	}
}

func (g *Generator) generateSQLiteExecution(w *strings.Builder, paramNames []string, hasColumns bool, cmd string, isSingleColumn bool, columns []*QueryColumn) {
	w.WriteString("    const sql = typeof stmt === 'string' ? stmt : stmt.text;\n")
	w.WriteString("    const prepared = this.db.prepare(sql);\n")

	if hasColumns {
		if cmd == ":one" {
			if len(paramNames) > 0 {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString(fmt.Sprintf("%s", "    const row = prepared.get("+strings.Join(paramNames, ", ")+");\n"))
					w.WriteString(fmt.Sprintf("    return row ? row.%s : null;\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.get(" + strings.Join(paramNames, ", ") + ") || null;\n")
				}
			} else {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const row = prepared.get();\n")
					w.WriteString(fmt.Sprintf("    return row ? row.%s : null;\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.get() || null;\n")
				}
			}
		} else {
			if len(paramNames) > 0 {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const rows = prepared.all(" + strings.Join(paramNames, ", ") + ");\n")
					w.WriteString(fmt.Sprintf("    return rows.map(row => row.%s);\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.all(" + strings.Join(paramNames, ", ") + ");\n")
				}
			} else {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const rows = prepared.all();\n")
					w.WriteString(fmt.Sprintf("    return rows.map(row => row.%s);\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.all();\n")
				}
			}
		}
	} else {
		if len(paramNames) > 0 {
			w.WriteString("    const info = prepared.run(" + strings.Join(paramNames, ", ") + ");\n")
		} else {
			w.WriteString("    const info = prepared.run();\n")
		}
		w.WriteString("    return info.changes;\n")
	}
}

func (g *Generator) getReturnType(query *Query) string {
	if len(query.Columns) == 1 && query.Columns[0].Name != "*" {
		colName := strings.ToLower(query.Columns[0].Name)
		if colName == "count" || colName == "sum" || colName == "avg" ||
			colName == "max" || colName == "min" || colName == "total" ||
			strings.HasSuffix(colName, "_count") || strings.HasSuffix(colName, "_sum") ||
			strings.HasPrefix(colName, "avg_") || strings.HasPrefix(colName, "total_") {
			return "number"
		}

		if colName == "exists" || strings.HasPrefix(colName, "is") || strings.HasPrefix(colName, "has") {
			return "boolean"
		}

		if query.Columns[0].Table != "" && g.cachedSchema != nil {
			for _, table := range g.cachedSchema.Tables {
				if strings.EqualFold(table.Name, query.Columns[0].Table) {
					for _, col := range table.Columns {
						if strings.EqualFold(col.Name, query.Columns[0].Name) {
							return g.mapSQLTypeToJS(col.Type)
						}
					}
				}
			}
		}
		return "any"
	}

	if len(query.Columns) == 1 && query.Columns[0].Name == "*" && query.Columns[0].Table != "" {
		return capitalize(query.Columns[0].Table)
	}

	if len(query.Columns) > 1 {
		return "Object"
	}

	if match := g.insertRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return capitalize(match[1])
	}

	if match := g.updateRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return capitalize(match[1])
	}

	if match := g.deleteRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return capitalize(match[1])
	}

	return "Object"
}

func (g *Generator) generateDatabase() error {
	var w strings.Builder
	w.WriteString("// Code generated by Graft. DO NOT EDIT.\n")
	w.WriteString("const { Queries } = require('./queries');\n\n")

	w.WriteString("/**\n")
	w.WriteString(" * Create a new database client\n")
	w.WriteString(" * @param {Object} db - Database connection (pg.Pool, mysql2.Pool, or better-sqlite3 instance)\n")
	w.WriteString(" * @returns {Queries}\n")
	w.WriteString(" */\n")
	w.WriteString("function New(db) {\n")
	w.WriteString("  return new Queries(db);\n")
	w.WriteString("}\n\n")

	w.WriteString("module.exports = { New, Queries };\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "database.js")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) mapSQLTypeToJS(sqlType string) string {
	sqlType = strings.ToLower(sqlType)

	switch {
	case contains(sqlType, "int"), contains(sqlType, "serial"):
		return "number"
	case contains(sqlType, "numeric"), contains(sqlType, "decimal"), contains(sqlType, "float"), contains(sqlType, "double"), contains(sqlType, "real"):
		return "number"
	case contains(sqlType, "bool"):
		return "boolean"
	case contains(sqlType, "json"):
		return "Object"
	case contains(sqlType, "timestamp"), contains(sqlType, "date"), contains(sqlType, "time"):
		return "Date"
	case contains(sqlType, "bytea"), contains(sqlType, "blob"):
		return "Uint8Array"
	default:
		return "string"
	}
}

func (g *Generator) convertSQL(sql string) string {
	switch g.Config.Database.Provider {
	case "mysql", "sqlite", "sqlite3":
		result := sql
		for i := 20; i >= 1; i-- {
			result = strings.ReplaceAll(result, fmt.Sprintf("$%d", i), "?")
		}
		return result
	default:
		return sql
	}
}

func capitalize(s string) string {
	if s == "" {
		return ""
	}
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func uncapitalize(s string) string {
	if s == "" {
		return ""
	}
	s = capitalize(s)
	return strings.ToLower(s[:1]) + s[1:]
}

func contains(s, substr string) bool {
	return strings.Contains(s, substr)
}
