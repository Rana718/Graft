package jsgen

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/Rana718/Graft/internal/config"
)

type Generator struct {
	Config *config.Config
}

func New(cfg *config.Config) *Generator {
	return &Generator{Config: cfg}
}

func (g *Generator) Generate() error {
	if err := os.MkdirAll(g.Config.Gen.JS.Out, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	queries, err := g.parseQueries()
	if err != nil {
		return fmt.Errorf("failed to parse queries: %w", err)
	}

	schema, err := g.parseSchema()
	if err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}

	if err := g.generateTypes(schema); err != nil {
		return err
	}

	if err := g.generateQueries(queries); err != nil {
		return err
	}

	if err := g.generateDatabase(); err != nil {
		return err
	}

	if err := g.generatePackageJSON(); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateTypes(schema *Schema) error {
	var w strings.Builder
	w.WriteString("// Code generated by Graft. DO NOT EDIT.\n\n")

	if len(schema.Tables) == 0 {
		w.WriteString("// No tables found in schema\n\n")
	}

	for _, table := range schema.Tables {
		structName := capitalize(table.Name)
		w.WriteString(fmt.Sprintf("/**\n * @typedef {Object} %s\n", structName))
		
		for _, col := range table.Columns {
			jsType := g.mapSQLTypeToJS(col.Type)
			nullable := ""
			if col.Nullable {
				nullable = "|null"
			}
			w.WriteString(fmt.Sprintf(" * @property {%s%s} %s\n", jsType, nullable, col.Name))
		}
		w.WriteString(" */\n\n")
	}

	w.WriteString("module.exports = {};\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "types.js")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) generateQueries(queries []*Query) error {
	var w strings.Builder
	w.WriteString("// Code generated by Graft. DO NOT EDIT.\n\n")

	w.WriteString("class Queries {\n")
	w.WriteString("  constructor(db) {\n")
	w.WriteString("    this.db = db;\n")
	w.WriteString("  }\n\n")

	for _, query := range queries {
		g.generateQueryMethod(&w, query)
	}

	w.WriteString("}\n\nmodule.exports = { Queries };\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "queries.js")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) generateQueryMethod(w *strings.Builder, query *Query) {
	methodName := uncapitalize(query.Name)

	w.WriteString("  /**\n")
	if query.Comment != "" {
		w.WriteString(fmt.Sprintf("   * %s\n", query.Comment))
	}

	paramNames := []string{}
	for i, param := range query.Params {
		paramName := param.Name
		if paramName == "" {
			paramName = fmt.Sprintf("param%d", i+1)
		}
		paramNames = append(paramNames, paramName)
		w.WriteString(fmt.Sprintf("   * @param {%s} %s\n", param.Type, paramName))
	}

	// Determine return type
	returnType := g.getReturnType(query)

	if query.Cmd == ":one" {
		w.WriteString(fmt.Sprintf("   * @returns {Promise<%s|null>}\n", returnType))
	} else if query.Cmd == ":many" {
		w.WriteString(fmt.Sprintf("   * @returns {Promise<%s[]>}\n", returnType))
	} else {
		w.WriteString("   * @returns {Promise<number>}\n")
	}
	w.WriteString("   */\n")

	w.WriteString(fmt.Sprintf("  async %s(%s) {\n", methodName, strings.Join(paramNames, ", ")))

	sql := g.convertSQL(query.SQL)
	sql = strings.ReplaceAll(sql, "`", "\\`")
	sql = strings.ReplaceAll(sql, "${", "\\${")

	if len(paramNames) > 0 {
		w.WriteString(fmt.Sprintf("    const result = await this.db.query(`%s`, [%s]);\n", sql, strings.Join(paramNames, ", ")))
	} else {
		w.WriteString(fmt.Sprintf("    const result = await this.db.query(`%s`);\n", sql))
	}

	if len(query.Columns) > 0 {
		if query.Cmd == ":one" {
			w.WriteString("    return result.rows?.[0] || null;\n")
		} else {
			w.WriteString("    return result.rows || [];\n")
		}
	} else {
		w.WriteString("    return result.rowCount || 0;\n")
	}

	w.WriteString("  }\n\n")
}

func (g *Generator) getReturnType(query *Query) string {
	// Check if query has columns (SELECT or RETURNING)
	if len(query.Columns) > 0 && query.Columns[0].Table != "" {
		return capitalize(query.Columns[0].Table)
	}
	
	// For INSERT/UPDATE/DELETE, extract table name from SQL
	// INSERT INTO table
	insertRegex := regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`)
	if match := insertRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return capitalize(match[1])
	}
	
	// UPDATE table
	updateRegex := regexp.MustCompile(`(?i)UPDATE\s+(\w+)`)
	if match := updateRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return capitalize(match[1])
	}
	
	// DELETE FROM table
	deleteRegex := regexp.MustCompile(`(?i)DELETE\s+FROM\s+(\w+)`)
	if match := deleteRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return capitalize(match[1])
	}
	
	return "Object"
}

func (g *Generator) generateDatabase() error {
	var w strings.Builder
	w.WriteString("// Code generated by Graft. DO NOT EDIT.\n")
	w.WriteString("const { Queries } = require('./queries');\n\n")

	w.WriteString("/**\n")
	w.WriteString(" * Create a new database client\n")
	w.WriteString(" * @param {Object} db - Database connection (pg.Pool, mysql2.Pool, or better-sqlite3 instance)\n")
	w.WriteString(" * @returns {Queries}\n")
	w.WriteString(" */\n")
	w.WriteString("function New(db) {\n")
	w.WriteString("  return new Queries(db);\n")
	w.WriteString("}\n\n")

	w.WriteString("module.exports = { New, Queries };\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "database.js")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) generatePackageJSON() error {
	var deps string

	switch g.Config.Database.Provider {
	case "mysql":
		deps = `    "mysql2": "^3.6.0"`
	case "sqlite", "sqlite3":
		deps = `    "better-sqlite3": "^9.0.0"`
	default:
		deps = `    "pg": "^8.11.0"`
	}

	content := fmt.Sprintf(`{
  "name": "%s",
  "version": "1.0.0",
  "description": "Generated JavaScript database client by Graft",
  "main": "database.js",
  "dependencies": {
%s
  }
}
`, g.Config.Gen.JS.Package, deps)

	path := filepath.Join(g.Config.Gen.JS.Out, "package.json")
	return os.WriteFile(path, []byte(content), 0644)
}

func (g *Generator) mapSQLTypeToJS(sqlType string) string {
	sqlType = strings.ToLower(sqlType)

	switch {
	case contains(sqlType, "int"), contains(sqlType, "serial"):
		return "number"
	case contains(sqlType, "numeric"), contains(sqlType, "decimal"), contains(sqlType, "float"), contains(sqlType, "double"), contains(sqlType, "real"):
		return "number"
	case contains(sqlType, "bool"):
		return "boolean"
	case contains(sqlType, "json"):
		return "Object"
	case contains(sqlType, "timestamp"), contains(sqlType, "date"), contains(sqlType, "time"):
		return "Date"
	case contains(sqlType, "bytea"), contains(sqlType, "blob"):
		return "Uint8Array"
	default:
		return "string"
	}
}

func (g *Generator) convertSQL(sql string) string {
	switch g.Config.Database.Provider {
	case "mysql", "sqlite", "sqlite3":
		result := sql
		for i := 20; i >= 1; i-- {
			result = strings.ReplaceAll(result, fmt.Sprintf("$%d", i), "?")
		}
		return result
	default:
		return sql
	}
}

func capitalize(s string) string {
	if s == "" {
		return ""
	}
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func uncapitalize(s string) string {
	if s == "" {
		return ""
	}
	s = capitalize(s)
	return strings.ToLower(s[:1]) + s[1:]
}

func contains(s, substr string) bool {
	return strings.Contains(s, substr)
}
