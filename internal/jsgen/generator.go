package jsgen

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/Rana718/Graft/internal/config"
)

type Generator struct {
	Config       *config.Config
	insertRegex  *regexp.Regexp
	updateRegex  *regexp.Regexp
	deleteRegex  *regexp.Regexp
	cachedSchema *Schema
}

func New(cfg *config.Config) *Generator {
	return &Generator{
		Config:      cfg,
		insertRegex: regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`),
		updateRegex: regexp.MustCompile(`(?i)UPDATE\s+(\w+)`),
		deleteRegex: regexp.MustCompile(`(?i)DELETE\s+FROM\s+(\w+)`),
	}
}

func (g *Generator) Generate() error {
	if err := os.MkdirAll(g.Config.Gen.JS.Out, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	schema, err := g.parseSchema()
	if err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}
	g.cachedSchema = schema

	queries, err := g.parseQueries()
	if err != nil {
		return fmt.Errorf("failed to parse queries: %w", err)
	}

	if err := g.generateQueries(queries); err != nil {
		return err
	}

	if err := g.generateDatabase(); err != nil {
		return err
	}

	return g.generateTypeScriptDeclarations(schema, queries)
}

func (g *Generator) generateQueries(queries []*Query) error {
	var w strings.Builder
	w.WriteString("// Code generated by Graft. DO NOT EDIT.\n\n")

	w.WriteString("class Queries {\n")
	w.WriteString("  constructor(db) {\n")
	w.WriteString("    this.db = db;\n")
	w.WriteString("    this._stmts = new Map();\n")
	w.WriteString("  }\n\n")

	for _, query := range queries {
		g.generateOptimizedQueryMethod(&w, query)
	}

	w.WriteString("}\n\nmodule.exports = { Queries };\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "queries.js")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) generateOptimizedQueryMethod(w *strings.Builder, query *Query) {
	methodName := uncapitalize(query.Name)
	sql := g.convertSQL(query.SQL)
	sql = strings.ReplaceAll(sql, "`", "\\`")
	sql = strings.ReplaceAll(sql, "${", "\\${")

	paramNames := make([]string, len(query.Params))
	for i, param := range query.Params {
		paramName := param.Name
		if paramName == "" {
			paramName = fmt.Sprintf("p%d", i+1)
		}
		paramNames[i] = paramName
	}

	hasColumns := len(query.Columns) > 0
	isSingleColumn := len(query.Columns) == 1 && query.Columns[0].Name != "*"
	isHotQuery := isSingleColumn && query.Cmd == ":one" && len(query.Params) <= 2

	w.WriteString(fmt.Sprintf("  async %s(%s) {\n", methodName, strings.Join(paramNames, ", ")))

	w.WriteString(fmt.Sprintf("    let stmt = this._stmts.get('%s');\n", methodName))
	w.WriteString("    if (!stmt) {\n")

	provider := g.Config.Database.Provider
	useNamedStmt := (provider == "" || provider == "postgresql" || provider == "postgres") &&
		(isHotQuery || len(query.Params) == 0)

	if useNamedStmt {
		w.WriteString(fmt.Sprintf("      stmt = { name: '%s', text: `%s` };\n", methodName, sql))
	} else {
		w.WriteString(fmt.Sprintf("      stmt = `%s`;\n", sql))
	}

	w.WriteString(fmt.Sprintf("      this._stmts.set('%s', stmt);\n", methodName))
	w.WriteString("    }\n")

	switch provider {
	case "sqlite", "sqlite3":
		g.generateSQLiteExecution(w, paramNames, hasColumns, query.Cmd, isSingleColumn, query.Columns)
	case "mysql":
		g.generateMySQLExecution(w, paramNames, hasColumns, query.Cmd, isSingleColumn, query.Columns)
	default:
		g.generatePostgreSQLExecution(w, paramNames, hasColumns, query.Cmd, isSingleColumn, query.Columns, isHotQuery)
	}

	w.WriteString("  }\n\n")
}

func (g *Generator) generatePostgreSQLExecution(w *strings.Builder, paramNames []string, hasColumns bool, cmd string, isSingleColumn bool, columns []*QueryColumn, isHotQuery bool) {
	if len(paramNames) > 0 {
		if isHotQuery {
			w.WriteString("    stmt.values = [" + strings.Join(paramNames, ", ") + "];\n")
			w.WriteString("    const r = await this.db.query(stmt);\n")
		} else {
			w.WriteString("    const r = await this.db.query(stmt, [" + strings.Join(paramNames, ", ") + "]);\n")
		}
	} else {
		if isHotQuery {
			w.WriteString("    stmt.values = [];\n")
			w.WriteString("    const r = await this.db.query(stmt);\n")
		} else {
			w.WriteString("    const r = await this.db.query(stmt);\n")
		}
	}

	if hasColumns {
		if cmd == ":one" {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r.rows[0] ? r.rows[0].%s : null;\n", columns[0].Name))
			} else {
				w.WriteString("    return r.rows[0] || null;\n")
			}
		} else {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r.rows.map(row => row.%s);\n", columns[0].Name))
			} else {
				w.WriteString("    return r.rows;\n")
			}
		}
	} else {
		w.WriteString("    return r.rowCount;\n")
	}
}

func (g *Generator) generateMySQLExecution(w *strings.Builder, paramNames []string, hasColumns bool, cmd string, isSingleColumn bool, columns []*QueryColumn) {
	w.WriteString("    const sql = typeof stmt === 'string' ? stmt : stmt.text;\n")
	if len(paramNames) > 0 {
		w.WriteString("    const r = await this.db.execute(sql, [" + strings.Join(paramNames, ", ") + "]);\n")
	} else {
		w.WriteString("    const r = await this.db.execute(sql);\n")
	}

	if hasColumns {
		if cmd == ":one" {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r[0][0] ? r[0][0].%s : null;\n", columns[0].Name))
			} else {
				w.WriteString("    return r[0][0] || null;\n")
			}
		} else {
			if isSingleColumn && len(columns) > 0 {
				w.WriteString(fmt.Sprintf("    return r[0].map(row => row.%s);\n", columns[0].Name))
			} else {
				w.WriteString("    return r[0];\n")
			}
		}
	} else {
		w.WriteString("    return r[0].affectedRows;\n")
	}
}

func (g *Generator) generateSQLiteExecution(w *strings.Builder, paramNames []string, hasColumns bool, cmd string, isSingleColumn bool, columns []*QueryColumn) {
	w.WriteString("    const sql = typeof stmt === 'string' ? stmt : stmt.text;\n")
	w.WriteString("    const prepared = this.db.prepare(sql);\n")

	if hasColumns {
		if cmd == ":one" {
			if len(paramNames) > 0 {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const row = prepared.get(" + strings.Join(paramNames, ", ") + ");\n")
					w.WriteString(fmt.Sprintf("    return row ? row.%s : null;\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.get(" + strings.Join(paramNames, ", ") + ") || null;\n")
				}
			} else {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const row = prepared.get();\n")
					w.WriteString(fmt.Sprintf("    return row ? row.%s : null;\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.get() || null;\n")
				}
			}
		} else {
			if len(paramNames) > 0 {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const rows = prepared.all(" + strings.Join(paramNames, ", ") + ");\n")
					w.WriteString(fmt.Sprintf("    return rows.map(row => row.%s);\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.all(" + strings.Join(paramNames, ", ") + ");\n")
				}
			} else {
				if isSingleColumn && len(columns) > 0 {
					w.WriteString("    const rows = prepared.all();\n")
					w.WriteString(fmt.Sprintf("    return rows.map(row => row.%s);\n", columns[0].Name))
				} else {
					w.WriteString("    return prepared.all();\n")
				}
			}
		}
	} else {
		if len(paramNames) > 0 {
			w.WriteString("    const info = prepared.run(" + strings.Join(paramNames, ", ") + ");\n")
		} else {
			w.WriteString("    const info = prepared.run();\n")
		}
		w.WriteString("    return info.changes;\n")
	}
}

func (g *Generator) getReturnType(query *Query) string {
	if len(query.Columns) == 1 && query.Columns[0].Name != "*" {
		colName := strings.ToLower(query.Columns[0].Name)
		if colName == "count" || colName == "sum" || colName == "avg" ||
			colName == "max" || colName == "min" || colName == "total" ||
			strings.HasSuffix(colName, "_count") || strings.HasSuffix(colName, "_sum") ||
			strings.HasPrefix(colName, "avg_") || strings.HasPrefix(colName, "total_") {
			return "number"
		}

		if colName == "exists" || strings.HasPrefix(colName, "is") || strings.HasPrefix(colName, "has") {
			return "boolean"
		}

		if query.Columns[0].Table != "" && g.cachedSchema != nil {
			for _, table := range g.cachedSchema.Tables {
				if strings.EqualFold(table.Name, query.Columns[0].Table) {
					for _, col := range table.Columns {
						if strings.EqualFold(col.Name, query.Columns[0].Name) {
							return g.mapSQLTypeToJS(col.Type)
						}
					}
				}
			}
		}
		return "any"
	}

	if len(query.Columns) == 1 && query.Columns[0].Name == "*" && query.Columns[0].Table != "" {
		return capitalize(query.Columns[0].Table)
	}

	if len(query.Columns) > 1 {
		return "Object"
	}

	if match := g.insertRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return capitalize(match[1])
	}

	if match := g.updateRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return capitalize(match[1])
	}

	if match := g.deleteRegex.FindStringSubmatch(query.SQL); len(match) > 1 {
		return capitalize(match[1])
	}

	return "Object"
}

func (g *Generator) generateDatabase() error {
	var w strings.Builder
	w.WriteString("// Code generated by Graft. DO NOT EDIT.\n")
	w.WriteString("const { Queries } = require('./queries');\n\n")

	w.WriteString("function New(db) {\n")
	w.WriteString("  return new Queries(db);\n")
	w.WriteString("}\n\n")

	w.WriteString("module.exports = { New, Queries };\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "database.js")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) mapSQLTypeToJS(sqlType string) string {
	sqlType = strings.ToLower(sqlType)

	switch {
	case contains(sqlType, "int"), contains(sqlType, "serial"):
		return "number"
	case contains(sqlType, "numeric"), contains(sqlType, "decimal"), contains(sqlType, "float"), contains(sqlType, "double"), contains(sqlType, "real"):
		return "number"
	case contains(sqlType, "bool"):
		return "boolean"
	case contains(sqlType, "json"):
		return "Object"
	case contains(sqlType, "timestamp"), contains(sqlType, "date"), contains(sqlType, "time"):
		return "Date"
	case contains(sqlType, "bytea"), contains(sqlType, "blob"):
		return "Uint8Array"
	default:
		return "string"
	}
}

func (g *Generator) convertSQL(sql string) string {
	switch g.Config.Database.Provider {
	case "mysql", "sqlite", "sqlite3":
		result := sql
		for i := 20; i >= 1; i-- {
			result = strings.ReplaceAll(result, fmt.Sprintf("$%d", i), "?")
		}
		return result
	default:
		return sql
	}
}

func capitalize(s string) string {
	if s == "" {
		return ""
	}
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func uncapitalize(s string) string {
	if s == "" {
		return ""
	}
	s = capitalize(s)
	return strings.ToLower(s[:1]) + s[1:]
}

func contains(s, substr string) bool {
	return strings.Contains(s, substr)
}

func (g *Generator) generateTypeScriptDeclarations(schema *Schema, queries []*Query) error {
	var w strings.Builder
	w.WriteString("// Code generated by Graft. DO NOT EDIT.\n\n")

	for _, table := range schema.Tables {
		structName := capitalize(table.Name)
		w.WriteString(fmt.Sprintf("export interface %s {\n", structName))
		for _, col := range table.Columns {
			jsType := g.mapSQLTypeToJS(col.Type)
			if col.Nullable {
				jsType += " | null"
			}
			w.WriteString(fmt.Sprintf("  %s: %s;\n", col.Name, jsType))
		}
		w.WriteString("}\n\n")
	}

	complexQueries := make(map[string]*Query)
	for _, query := range queries {
		if len(query.Columns) > 1 && query.Cmd != ":exec" {
			complexQueries[query.Name] = query
		}
	}

	for queryName, query := range complexQueries {
		interfaceName := capitalize(queryName) + "Result"
		w.WriteString(fmt.Sprintf("export interface %s {\n", interfaceName))
		
		for _, col := range query.Columns {
			colType := g.inferColumnTypeFromSchema(col, query, schema)
			w.WriteString(fmt.Sprintf("  %s: %s;\n", col.Name, colType))
		}
		w.WriteString("}\n\n")
	}

	w.WriteString("export class Queries {\n")
	w.WriteString("  constructor(db: any);\n\n")

	seenMethods := make(map[string]bool)
	for _, query := range queries {
		methodName := uncapitalize(query.Name)
		
		if seenMethods[methodName] {
			continue
		}
		seenMethods[methodName] = true
		
		params := make([]string, len(query.Params))
		for i, param := range query.Params {
			paramName := param.Name
			if paramName == "" {
				paramName = fmt.Sprintf("p%d", i+1)
			}
			params[i] = fmt.Sprintf("%s: %s", paramName, param.Type)
		}

		returnType := g.getReturnType(query)
		
		if len(query.Columns) > 1 && query.Cmd != ":exec" {
			returnType = capitalize(query.Name) + "Result"
		}
		
		switch query.Cmd {
		case ":one":
			returnType = fmt.Sprintf("Promise<%s | null>", returnType)
		case ":many":
			returnType = fmt.Sprintf("Promise<%s[]>", returnType)
		default:
			returnType = "Promise<number>"
		}

		w.WriteString(fmt.Sprintf("  %s(%s): %s;\n", methodName, strings.Join(params, ", "), returnType))
	}

	w.WriteString("}\n\n")
	w.WriteString("export function New(db: any): Queries;\n")

	path := filepath.Join(g.Config.Gen.JS.Out, "index.d.ts")
	return os.WriteFile(path, []byte(w.String()), 0644)
}

func (g *Generator) inferColumnTypeFromSchema(col *QueryColumn, query *Query, schema *Schema) string {
	colName := strings.ToLower(col.Name)
	
	if strings.Contains(colName, "count") || strings.Contains(colName, "total") || 
	   strings.Contains(colName, "sum") {
		return "number"
	}
	if strings.Contains(colName, "avg") {
		return "number | null"
	}
	
	if col.Table != "" {
		for _, table := range schema.Tables {
			if strings.EqualFold(table.Name, col.Table) {
				for _, schemaCol := range table.Columns {
					if strings.EqualFold(schemaCol.Name, col.Name) {
						jsType := g.mapSQLTypeToJS(schemaCol.Type)
						if schemaCol.Nullable {
							jsType += " | null"
						}
						return jsType
					}
				}
			}
		}
	}
	
	tableAliases := g.extractTableAliases(query.SQL)
	
	for _, tableName := range tableAliases {
		for _, table := range schema.Tables {
			if strings.EqualFold(table.Name, tableName) {
				for _, schemaCol := range table.Columns {
					if strings.EqualFold(schemaCol.Name, col.Name) {
						jsType := g.mapSQLTypeToJS(schemaCol.Type)
						if schemaCol.Nullable {
							jsType += " | null"
						}
						return jsType
					}
				}
			}
		}
	}
	
	if strings.Contains(colName, "date") || strings.Contains(colName, "time") {
		return "Date"
	}
	if strings.Contains(colName, "id") || strings.HasSuffix(colName, "_id") {
		return "number"
	}
	if strings.Contains(colName, "is") || strings.Contains(colName, "has") {
		return "boolean"
	}
	
	return "string"
}

func (g *Generator) extractTableAliases(sql string) map[string]string {
	aliases := make(map[string]string)
	
	fromRe := regexp.MustCompile(`(?i)FROM\s+(\w+)\s+(\w+)`)
	if matches := fromRe.FindStringSubmatch(sql); len(matches) > 2 {
		aliases[matches[2]] = matches[1]
	}
	
	joinRe := regexp.MustCompile(`(?i)JOIN\s+(\w+)\s+(\w+)`)
	for _, matches := range joinRe.FindAllStringSubmatch(sql, -1) {
		if len(matches) > 2 {
			aliases[matches[2]] = matches[1]
		}
	}
	
	return aliases
}
