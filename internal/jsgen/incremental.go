package jsgen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/Lumos-Labs-HQ/flash/internal/gencommon"
	"github.com/Lumos-Labs-HQ/flash/internal/parser"
)

// generateQueriesIncremental generates JavaScript queries with incremental support
func (g *Generator) generateQueriesIncremental(queries []*parser.Query, fullRegen bool) error {
	queryGroups := make(map[string][]*parser.Query)
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries"
		}
		queryGroups[sourceFile] = append(queryGroups[sourceFile], query)
	}

	usedNames := make(map[string]int)

	for sourceFile, fileQueries := range queryGroups {
		queryFile := filepath.Join(g.Config.Queries, sourceFile+".sql")
		currentHash, _ := gencommon.ComputeFileChecksum(queryFile)

		if !gencommon.ShouldRegenerateFile(g.cache, queryFile, currentHash, fullRegen) {
			gencommon.PrintSkipMessage(sourceFile, ".js")
			continue
		}

		gencommon.PrintGenerateMessage(sourceFile, ".js")
		
		estimatedSize := 200 + (len(fileQueries) * 400)
		var w strings.Builder
		w.Grow(estimatedSize)

		w.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n\n")
		w.WriteString("class Queries {\n")
		w.WriteString("  constructor(db) {\n")
		w.WriteString("    this.db = db;\n")
		w.WriteString("    this._stmts = new Map();\n")
		w.WriteString("  }\n\n")

		for _, query := range fileQueries {
			g.generateOptimizedQueryMethod(&w, query)
		}

		w.WriteString("}\n\nmodule.exports = { Queries };\n")

		baseName := strings.TrimSuffix(sourceFile, ".sql")
		outputFile := baseName + ".js"

		if count, exists := usedNames[baseName]; exists {
			usedNames[baseName] = count + 1
			outputFile = fmt.Sprintf("%s_%d.js", baseName, count+1)
		} else {
			usedNames[baseName] = 1
		}

		path := filepath.Join(g.Config.Gen.JS.Out, outputFile)
		if err := os.WriteFile(path, []byte(w.String()), 0644); err != nil {
			return err
		}

		tableDeps := gencommon.ExtractTableDependencies(fileQueries)
		gencommon.UpdateCacheForFile(g.cache, queryFile, currentHash, tableDeps, path)
	}

	return nil
}
