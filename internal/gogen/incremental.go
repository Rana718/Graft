package gogen

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"

	"github.com/Lumos-Labs-HQ/flash/internal/gencommon"
	"github.com/Lumos-Labs-HQ/flash/internal/parser"
)

// generateQueriesIncremental generates queries with incremental support  
func (g *Generator) generateQueriesIncremental(queries []*parser.Query, fullRegen bool) error {
	queryGroups := make(map[string][]*parser.Query)
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries"
		}
		queryGroups[sourceFile] = append(queryGroups[sourceFile], query)
	}

	// Convert map to slice for parallel processing
	type fileGroup struct {
		sourceFile string
		queries    []*parser.Query
	}
	
	fileGroups := make([]fileGroup, 0, len(queryGroups))
	for sourceFile, fileQueries := range queryGroups {
		fileGroups = append(fileGroups, fileGroup{sourceFile, fileQueries})
	}

	// Track used names across parallel workers (thread-safe)
	usedNames := make(map[string]int)
	var usedNamesMu sync.Mutex

	// Parallel code generation with worker pool
	numWorkers := runtime.NumCPU()
	if numWorkers > len(fileGroups) {
		numWorkers = len(fileGroups)
	}

	type generateResult struct {
		err error
	}

	workChan := make(chan fileGroup, len(fileGroups))
	resultChan := make(chan generateResult, len(fileGroups))

	var wg sync.WaitGroup
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for fg := range workChan {
				err := g.generateSingleFile(fg.sourceFile, fg.queries, fullRegen, &usedNamesMu, usedNames)
				resultChan <- generateResult{err: err}
			}
		}()
	}

	// Send work to workers
	for _, fg := range fileGroups {
		workChan <- fg
	}
	close(workChan)

	// Wait for completion
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Collect results and check for errors
	for result := range resultChan {
		if result.err != nil {
			return result.err
		}
	}

	return nil
}

// generateSingleFile generates code for a single query file (thread-safe)
func (g *Generator) generateSingleFile(sourceFile string, fileQueries []*parser.Query, fullRegen bool, usedNamesMu *sync.Mutex, usedNames map[string]int) error {
	queryFile := filepath.Join(g.Config.Queries, sourceFile+".sql")
	currentHash, _ := gencommon.ComputeFileChecksum(queryFile)
	
	if !gencommon.ShouldRegenerateFile(g.cache, queryFile, currentHash, fullRegen) {
		gencommon.PrintSkipMessage(sourceFile, ".go")
		return nil
	}

	gencommon.PrintGenerateMessage(sourceFile, ".go")
	
	// Use pooled string builder
	code := gencommon.GetBuilder()
	defer gencommon.PutBuilder(code)

	code.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n\n")
	code.WriteString("package flash_gen\n\n")

	needsTime, needsSQL := false, false
	for _, query := range fileQueries {
		for _, col := range query.Columns {
			colType := g.mapColumnTypeToGo(col.Type, col.Nullable)
			if strings.Contains(colType, "time.Time") {
				needsTime = true
			}
			if strings.Contains(colType, "sql.Null") {
				needsSQL = true
			}
		}
		if strings.ToLower(query.Cmd) == ":one" {
			needsSQL = true
		}
	}

	imports := []string{}
	if needsSQL {
		imports = append(imports, "\"database/sql\"")
	}
	if needsTime {
		imports = append(imports, "\"time\"")
	}

	if len(imports) > 0 {
		code.WriteString("import (\n")
		for _, imp := range imports {
			code.WriteString(fmt.Sprintf("\t%s\n", imp))
		}
		code.WriteString(")\n\n")
	}

	for _, query := range fileQueries {
		if err := g.generateQueryMethod(code, query); err != nil {
			return err
		}
	}

	baseName := strings.TrimSuffix(sourceFile, ".sql")
	
	// Thread-safe name deduplication
	usedNamesMu.Lock()
	outputFile := baseName + ".go"
	if count, exists := usedNames[baseName]; exists {
		usedNames[baseName] = count + 1
		outputFile = fmt.Sprintf("%s_%d.go", baseName, count+1)
	} else {
		usedNames[baseName] = 1
	}
	usedNamesMu.Unlock()

	queriesPath := filepath.Join("flash_gen", outputFile)
	if err := os.WriteFile(queriesPath, []byte(code.String()), 0644); err != nil {
		return err
	}

	tableDeps := gencommon.ExtractTableDependencies(fileQueries)
	gencommon.UpdateCacheForFile(g.cache, queryFile, currentHash, tableDeps, queriesPath)

	return nil
}
