package gogen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/Lumos-Labs-HQ/flash/internal/config"
	"github.com/Lumos-Labs-HQ/flash/internal/parser"
	"github.com/Lumos-Labs-HQ/flash/internal/utils"
)

type Generator struct {
	Config       *config.Config
	schema       *parser.Schema
	schemaParser *parser.SchemaParser
	queryParser  *parser.QueryParser
}

func New(cfg *config.Config) *Generator {
	return &Generator{
		Config:       cfg,
		schemaParser: parser.NewSchemaParser(cfg),
		queryParser:  parser.NewQueryParser(cfg),
	}
}

func (g *Generator) Generate() error {
	if err := os.MkdirAll("flash_gen", 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	schema, err := g.schemaParser.Parse()
	if err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}
	g.schema = schema

	queries, err := g.queryParser.Parse(schema)
	if err != nil {
		return fmt.Errorf("failed to parse queries: %w", err)
	}

	if err := g.generateModels(); err != nil {
		return err
	}

	if err := g.generateDB(); err != nil {
		return err
	}

	if err := g.generateQueries(queries); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateModels() error {
	// Extract inline MySQL ENUMs and add them to schema.Enums
	enumTypeMap := g.extractInlineEnums()

	needsTime := false
	needsSQL := false

	for _, table := range g.schema.Tables {
		for _, col := range table.Columns {
			goType := g.mapSQLTypeToGoWithEnumMap(col.Type, col.Nullable, enumTypeMap)
			if strings.Contains(goType, "time.Time") {
				needsTime = true
			}
			if strings.Contains(goType, "sql.Null") {
				needsSQL = true
			}
		}
	}

	// Pre-allocate: ~200 bytes header + ~150 bytes per table + ~100 per enum
	estimatedSize := 200 + (len(g.schema.Tables) * 150) + (len(g.schema.Enums) * 100)
	var code strings.Builder
	code.Grow(estimatedSize)

	code.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n\n")
	code.WriteString("package flash_gen\n\n")

	// Only add imports if needed
	if needsTime || needsSQL {
		code.WriteString("import (\n")
		if needsSQL {
			code.WriteString("\t\"database/sql\"\n")
		}
		if needsTime {
			code.WriteString("\t\"time\"\n")
		}
		code.WriteString(")\n\n")
	}

	for _, enum := range g.schema.Enums {
		enumName := utils.ToPascalCase(enum.Name)
		code.WriteString(fmt.Sprintf("type %s string\n\n", enumName))
		code.WriteString("const (\n")
		for _, val := range enum.Values {
			constName := fmt.Sprintf("%s%s", enumName, utils.ToPascalCase(val))
			code.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, enumName, val))
		}
		code.WriteString(")\n\n")
	}

	for _, table := range g.schema.Tables {
		structName := utils.ToPascalCase(table.Name)
		code.WriteString(fmt.Sprintf("type %s struct {\n", structName))
		for _, col := range table.Columns {
			fieldName := utils.ToPascalCase(col.Name)
			goType := g.mapSQLTypeToGoWithEnumMap(col.Type, col.Nullable, enumTypeMap)
			jsonTag := utils.ToSnakeCase(col.Name)
			code.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\" db:\"%s\"`\n", fieldName, goType, jsonTag, col.Name))
		}
		code.WriteString("}\n\n")
	}

	modelsPath := filepath.Join("flash_gen", "models.go")
	return os.WriteFile(modelsPath, []byte(code.String()), 0644)
}

func (g *Generator) generateDB() error {
	// Pre-allocate buffer for DB interface code
	var code strings.Builder
	code.Grow(500)

	code.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n\n")
	code.WriteString("package flash_gen\n\n")
	code.WriteString("import (\n")
	code.WriteString("\t\"database/sql\"\n")
	code.WriteString(")\n\n")
	code.WriteString("type DBTX interface {\n")
	code.WriteString("\tExec(query string, args ...interface{}) (sql.Result, error)\n")
	code.WriteString("\tPrepare(query string) (*sql.Stmt, error)\n")
	code.WriteString("\tQuery(query string, args ...interface{}) (*sql.Rows, error)\n")
	code.WriteString("\tQueryRow(query string, args ...interface{}) *sql.Row\n")
	code.WriteString("}\n\n")
	code.WriteString("func New(db DBTX) *Queries {\n")
	code.WriteString("\treturn &Queries{\n")
	code.WriteString("\t\tdb:    db,\n")
	code.WriteString("\t\tstmts: make(map[string]*sql.Stmt),\n")
	code.WriteString("\t}\n")
	code.WriteString("}\n\n")
	code.WriteString("// OPTIMIZED: Queries struct with prepared statement cache\n")
	code.WriteString("// This provides 2-5x performance improvement for repeated queries\n")
	code.WriteString("type Queries struct {\n")
	code.WriteString("\tdb    DBTX\n")
	code.WriteString("\tstmts map[string]*sql.Stmt // Statement cache for hot queries\n")
	code.WriteString("}\n\n")
	code.WriteString("// Close closes all prepared statements\n")
	code.WriteString("func (q *Queries) Close() error {\n")
	code.WriteString("\tfor _, stmt := range q.stmts {\n")
	code.WriteString("\t\tif err := stmt.Close(); err != nil {\n")
	code.WriteString("\t\t\treturn err\n")
	code.WriteString("\t\t}\n")
	code.WriteString("\t}\n")
	code.WriteString("\tq.stmts = make(map[string]*sql.Stmt)\n")
	code.WriteString("\treturn nil\n")
	code.WriteString("}\n\n")

	dbPath := filepath.Join("flash_gen", "db.go")
	return os.WriteFile(dbPath, []byte(code.String()), 0644)
}

func (g *Generator) generateQueries(queries []*parser.Query) error {
	queryGroups := make(map[string][]*parser.Query)
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries"
		}
		queryGroups[sourceFile] = append(queryGroups[sourceFile], query)
	}

	usedNames := make(map[string]int)

	for sourceFile, fileQueries := range queryGroups {
		// Pre-allocate: ~200 bytes header + ~400 bytes per query + ~200 bytes per table for types
		estimatedSize := 200 + (len(fileQueries) * 400) + (len(g.schema.Tables) * 200)
		var code strings.Builder
		code.Grow(estimatedSize)

		code.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n\n")
		code.WriteString("package flash_gen\n\n")

		needsTime := false
		needsSQL := false

		for _, query := range fileQueries {
			for _, col := range query.Columns {
				colType := g.mapColumnTypeToGo(col.Type, col.Nullable)
				if strings.Contains(colType, "time.Time") {
					needsTime = true
				}
				if strings.Contains(colType, "sql.Null") {
					needsSQL = true
				}
			}
			if strings.ToLower(query.Cmd) == ":one" {
				needsSQL = true
			}
		}

		imports := []string{}
		if needsSQL {
			imports = append(imports, "\"database/sql\"")
		}
		if needsTime {
			imports = append(imports, "\"time\"")
		}

		if len(imports) > 0 {
			code.WriteString("import (\n")
			for _, imp := range imports {
				code.WriteString(fmt.Sprintf("\t%s\n", imp))
			}
			code.WriteString(")\n\n")
		}

		for _, query := range fileQueries {
			if err := g.generateQueryMethod(&code, query); err != nil {
				return err
			}
		}

		baseName := strings.TrimSuffix(sourceFile, ".sql")
		outputFile := baseName + ".go"

		if count, exists := usedNames[baseName]; exists {
			usedNames[baseName] = count + 1
			outputFile = fmt.Sprintf("%s_%d.go", baseName, count+1)
		} else {
			usedNames[baseName] = 1
		}

		queriesPath := filepath.Join("flash_gen", outputFile)
		if err := os.WriteFile(queriesPath, []byte(code.String()), 0644); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) expandWildcardColumns(query *parser.Query) []*parser.QueryColumn {
	hasReturning := strings.Contains(strings.ToUpper(query.SQL), "RETURNING")

	// No columns and no RETURNING clause - nothing to expand
	if len(query.Columns) == 0 && !hasReturning {
		return query.Columns
	}

	// Single non-wildcard column - no expansion needed
	if len(query.Columns) == 1 && query.Columns[0].Name != "*" {
		return query.Columns
	}

	// Multiple columns - check if any is a wildcard
	if len(query.Columns) > 1 {
		hasWildcard := false
		for _, col := range query.Columns {
			if col.Name == "*" {
				hasWildcard = true
				break
			}
		}
		if !hasWildcard {
			return query.Columns
		}
	}

	tableName := utils.ExtractTableName(query.SQL)
	if tableName == "" {
		return query.Columns
	}

	var table *parser.Table
	for _, t := range g.schema.Tables {
		if strings.EqualFold(t.Name, tableName) {
			table = t
			break
		}
	}

	if table == nil {
		return query.Columns
	}

	expanded := make([]*parser.QueryColumn, 0, len(table.Columns))
	for _, col := range table.Columns {
		expanded = append(expanded, &parser.QueryColumn{
			Name:     col.Name,
			Type:     col.Type,
			Table:    table.Name,
			Nullable: col.Nullable,
		})
	}

	return expanded
}



func (g *Generator) generateQueryMethod(code *strings.Builder, query *parser.Query) error {
	columns := g.expandWildcardColumns(query)

	methodName := utils.ToPascalCase(query.Name)

	useStructParams := len(query.Params) > 3

	if useStructParams && len(query.Params) > 0 {
		code.WriteString(fmt.Sprintf("type %sParams struct {\n", methodName))
		for _, param := range query.Params {
			fieldName := utils.ToPascalCase(param.Name)
			goType := g.mapParamTypeToGo(param.Type)
			code.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, utils.ToSnakeCase(param.Name)))
		}
		code.WriteString("}\n\n")
	}

	cmd := strings.ToLower(query.Cmd)
	isModifying := utils.IsModifyingQuery(query.SQL)

	code.WriteString(fmt.Sprintf("func (q *Queries) %s(", methodName))

	if len(query.Params) > 0 {
		if useStructParams {
			code.WriteString(fmt.Sprintf("arg %sParams", methodName))
		} else {
			paramList := []string{}
			for _, param := range query.Params {
				paramName := utils.ToSnakeCase(param.Name)
				goType := g.mapParamTypeToGo(param.Type)
				paramList = append(paramList, fmt.Sprintf("%s %s", paramName, goType))
			}
			code.WriteString(strings.Join(paramList, ", "))
		}
	}

	code.WriteString(") (")

	switch {
	case cmd == ":one":
		if len(columns) == 1 {
			code.WriteString(fmt.Sprintf("%s, error", g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable)))
		} else {
			code.WriteString(fmt.Sprintf("%sRow, error", methodName))
		}
	case cmd == ":many":
		if len(columns) == 1 {
			code.WriteString(fmt.Sprintf("[]%s, error", g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable)))
		} else {
			code.WriteString(fmt.Sprintf("[]%sRow, error", methodName))
		}
	case cmd == ":exec" || isModifying:
		code.WriteString("error")
	case cmd == ":execresult":
		code.WriteString("sql.Result, error")
	default:
		code.WriteString("error")
	}

	code.WriteString(") {\n")

	cleanSQL := strings.TrimSpace(query.SQL)
	code.WriteString(fmt.Sprintf("\tconst query = `%s`\n", cleanSQL))

	isHotQuery := len(query.Params) <= 3 && !strings.Contains(strings.ToUpper(query.SQL), "UNION")
	stmtKey := fmt.Sprintf("%s_stmt", methodName)

	if isHotQuery {
		code.WriteString("\t// OPTIMIZED: Use prepared statement cache for hot query\n")
		code.WriteString(fmt.Sprintf("\tstmt := q.stmts[\"%s\"]\n", stmtKey))
		code.WriteString("\tif stmt == nil {\n")
		code.WriteString("\t\tvar err error\n")
		code.WriteString("\t\tstmt, err = q.db.Prepare(query)\n")
		code.WriteString("\t\tif err != nil {\n")

		// Return appropriate zero value based on return type
		if len(columns) > 0 {
			// Query returns data (SELECT or INSERT RETURNING)
			if cmd == ":one" {
				if len(columns) == 1 {
					code.WriteString("\t\t\treturn ")
					code.WriteString(g.getZeroValue(g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable)))
					code.WriteString(", err\n")
				} else {
					code.WriteString(fmt.Sprintf("\t\t\treturn %sRow{}, err\n", methodName))
				}
			} else {
				// :many or default (returns slice)
				code.WriteString("\t\t\treturn nil, err\n")
			}
		} else if cmd == ":execresult" {
			code.WriteString("\t\t\treturn nil, err\n")
		} else {
			// :exec or modifying query without RETURNING
			code.WriteString("\t\t\treturn err\n")
		}

		code.WriteString("\t\t}\n")
		code.WriteString(fmt.Sprintf("\t\tq.stmts[\"%s\"] = stmt\n", stmtKey))
		code.WriteString("\t}\n")
	}

	if len(query.Params) > 0 {
		code.WriteString("\targs := []interface{}{")
		for i, param := range query.Params {
			if i > 0 {
				code.WriteString(", ")
			}
			if useStructParams {
				code.WriteString(fmt.Sprintf("arg.%s", utils.ToPascalCase(param.Name)))
			} else {
				code.WriteString(utils.ToSnakeCase(param.Name))
			}
		}
		code.WriteString("}\n")
	}

	switch {
	case cmd == ":one":
		if len(columns) == 0 {
			code.WriteString("\n\treturn nil, fmt.Errorf(\"query has no return columns\")\n")
		} else if len(columns) > 1 {
			code.WriteString(fmt.Sprintf("\n\tvar result %sRow\n", methodName))
			if isHotQuery {
				code.WriteString("\trows, err := stmt.Query(")
				if len(query.Params) > 0 {
					code.WriteString("args...")
				}
			} else {
				code.WriteString("\trows, err := q.db.Query(query")
				if len(query.Params) > 0 {
					code.WriteString(", args...")
				}
			}
			code.WriteString(")\n")
			code.WriteString("\tif err != nil {\n")
			code.WriteString("\t\treturn result, err\n")
			code.WriteString("\t}\n")
			code.WriteString("\tdefer rows.Close()\n")
			code.WriteString("\tif !rows.Next() {\n")
			code.WriteString("\t\tif err := rows.Err(); err != nil {\n")
			code.WriteString("\t\t\treturn result, err\n")
			code.WriteString("\t\t}\n")
			code.WriteString("\t\treturn result, sql.ErrNoRows\n")
			code.WriteString("\t}\n")
			code.WriteString("\terr = rows.Scan(")
			for i, col := range columns {
				if i > 0 {
					code.WriteString(", ")
				}
				code.WriteString(fmt.Sprintf("&result.%s", utils.ToPascalCase(col.Name)))
			}
			code.WriteString(")\n")
			code.WriteString("\treturn result, err\n")
		} else {
			code.WriteString("\n\tvar result ")
			code.WriteString(g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable))
			if isHotQuery {
				code.WriteString("\n\trows, err := stmt.Query(")
				if len(query.Params) > 0 {
					code.WriteString("args...")
				}
			} else {
				code.WriteString("\n\trows, err := q.db.Query(query")
				if len(query.Params) > 0 {
					code.WriteString(", args...")
				}
			}
			code.WriteString(")\n")
			code.WriteString("\tif err != nil {\n")
			code.WriteString("\t\treturn result, err\n")
			code.WriteString("\t}\n")
			code.WriteString("\tdefer rows.Close()\n")
			code.WriteString("\tif !rows.Next() {\n")
			code.WriteString("\t\tif err := rows.Err(); err != nil {\n")
			code.WriteString("\t\t\treturn result, err\n")
			code.WriteString("\t\t}\n")
			code.WriteString("\t\treturn result, sql.ErrNoRows\n")
			code.WriteString("\t}\n")
			code.WriteString("\terr = rows.Scan(&result)\n")
			code.WriteString("\treturn result, err\n")
		}

	case cmd == ":many":
		if len(columns) == 0 {
			code.WriteString("\n\treturn nil, fmt.Errorf(\"query has no return columns\")\n")
		} else {
			if isHotQuery {
				code.WriteString("\n\trows, err := stmt.Query(")
				if len(query.Params) > 0 {
					code.WriteString("args...")
				}
			} else {
				code.WriteString("\n\trows, err := q.db.Query(query")
				if len(query.Params) > 0 {
					code.WriteString(", args...")
				}
			}
			code.WriteString(")\n")
			code.WriteString("\tif err != nil {\n")
			code.WriteString("\t\treturn nil, err\n")
			code.WriteString("\t}\n")
			code.WriteString("\tdefer rows.Close()\n\n")

			if len(columns) > 1 {
				code.WriteString(fmt.Sprintf("\titems := make([]%sRow, 0, 8) // Pre-allocate for typical result size\n", methodName))
			} else {
				code.WriteString(fmt.Sprintf("\titems := make([]%s, 0, 8) // Pre-allocate for typical result size\n", g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable)))
			}

			code.WriteString("\tfor rows.Next() {\n")
			if len(columns) > 1 {
				code.WriteString(fmt.Sprintf("\t\tvar item %sRow\n", methodName))
				code.WriteString("\t\tif err := rows.Scan(")
				for i, col := range columns {
					if i > 0 {
						code.WriteString(", ")
					}
					code.WriteString(fmt.Sprintf("&item.%s", utils.ToPascalCase(col.Name)))
				}
				code.WriteString("); err != nil {\n")
				code.WriteString("\t\t\treturn nil, err\n")
				code.WriteString("\t\t}\n")
				code.WriteString("\t\titems = append(items, item)\n")
			} else {
				code.WriteString("\t\tvar item ")
				code.WriteString(g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable))
				code.WriteString("\n\t\tif err := rows.Scan(&item); err != nil {\n")
				code.WriteString("\t\t\treturn nil, err\n")
				code.WriteString("\t\t}\n")
				code.WriteString("\t\titems = append(items, item)\n")
			}
			code.WriteString("\t}\n")
			code.WriteString("\treturn items, rows.Err()\n")
		}

	case cmd == ":execresult":
		if isHotQuery {
			code.WriteString("\n\treturn stmt.Exec(")
			if len(query.Params) > 0 {
				code.WriteString("args...")
			}
		} else {
			code.WriteString("\n\treturn q.db.Exec(query")
			if len(query.Params) > 0 {
				code.WriteString(", args...")
			}
		}
		code.WriteString(")\n")

	default:
		if isHotQuery {
			code.WriteString("\n\t_, err := stmt.Exec(")
			if len(query.Params) > 0 {
				code.WriteString("args...")
			}
		} else {
			code.WriteString("\n\t_, err := q.db.Exec(query")
			if len(query.Params) > 0 {
				code.WriteString(", args...")
			}
		}
		code.WriteString(")\n")
		code.WriteString("\treturn err\n")
	}

	code.WriteString("}\n\n")

	if (cmd == ":one" || cmd == ":many") && len(columns) > 1 {
		code.WriteString(fmt.Sprintf("type %sRow struct {\n", methodName))
		for _, col := range columns {
			fieldName := utils.ToPascalCase(col.Name)
			goType := g.mapColumnTypeToGo(col.Type, col.Nullable)
			code.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, utils.ToSnakeCase(col.Name)))
		}
		code.WriteString("}\n\n")
	}

	return nil
}



func (g *Generator) mapSQLTypeToGo(sqlType string, nullable bool) string {
	sqlTypeLower := strings.ToLower(sqlType)

	if g.schema != nil {
		for _, enum := range g.schema.Enums {
			if strings.ToLower(enum.Name) == sqlTypeLower {
				enumType := utils.ToPascalCase(enum.Name)
				if nullable {
					return "sql.NullString"
				}
				return enumType
			}
		}
	}

	// Handle MySQL inline ENUM types: enum('val1','val2','val3')
	if strings.HasPrefix(sqlTypeLower, "enum(") {
		if nullable {
			return "sql.NullString"
		}
		return "string"
	}

	baseType := ""
	switch {
	case strings.Contains(sqlTypeLower, "int"):
		baseType = "int64"
	case strings.Contains(sqlTypeLower, "serial"):
		baseType = "int64"
	case strings.Contains(sqlTypeLower, "float") || strings.Contains(sqlTypeLower, "double") || strings.Contains(sqlTypeLower, "numeric") || strings.Contains(sqlTypeLower, "decimal"):
		baseType = "float64"
	case strings.Contains(sqlTypeLower, "bool"):
		baseType = "bool"
	case strings.Contains(sqlTypeLower, "time") || strings.Contains(sqlTypeLower, "date"):
		baseType = "time.Time"
	case strings.Contains(sqlTypeLower, "json"):
		baseType = "[]byte"
	case strings.Contains(sqlTypeLower, "uuid"):
		baseType = "string"
	default:
		baseType = "string"
	}

	if nullable {
		switch baseType {
		case "int64":
			return "sql.NullInt64"
		case "float64":
			return "sql.NullFloat64"
		case "bool":
			return "sql.NullBool"
		case "string":
			return "sql.NullString"
		case "time.Time":
			return "sql.NullTime"
		default:
			return "*" + baseType
		}
	}

	return baseType
}

func (g *Generator) mapParamTypeToGo(paramType string) string {
	if strings.Contains(paramType, "|") {
		parts := strings.Split(paramType, "|")
		paramType = strings.TrimSpace(parts[0])
	}

	if g.schema != nil {
		for _, enum := range g.schema.Enums {
			if strings.EqualFold(enum.Name, paramType) {
				return utils.ToPascalCase(enum.Name)
			}
		}
	}

	return g.mapSQLTypeToGo(paramType, false)
}

func (g *Generator) mapColumnTypeToGo(colType string, nullable bool) string {
	return g.mapSQLTypeToGo(colType, nullable)
}

// mapSQLTypeToGoWithEnumMap maps SQL types to Go types using enum type map for MySQL inline ENUMs
func (g *Generator) mapSQLTypeToGoWithEnumMap(sqlType string, nullable bool, enumTypeMap map[string]string) string {
	sqlTypeLower := strings.ToLower(sqlType)

	if enumName, ok := enumTypeMap[sqlTypeLower]; ok {
		typeName := utils.ToPascalCase(enumName)
		if nullable {
			return "sql.NullString"
		}
		return typeName
	}

	return g.mapSQLTypeToGo(sqlType, nullable)
}

// getZeroValue returns the zero value for a given Go type
func (g *Generator) getZeroValue(goType string) string {
	switch {
	case strings.HasPrefix(goType, "[]"):
		return "nil"
	case strings.Contains(goType, "sql.Null"):
		return goType + "{}"
	case goType == "string":
		return `""`
	case goType == "int", goType == "int32", goType == "int64", goType == "float32", goType == "float64":
		return "0"
	case goType == "bool":
		return "false"
	case strings.Contains(goType, "time.Time"):
		return "time.Time{}"
	default:
		return goType + "{}"
	}
}

// extractInlineEnums extracts MySQL inline ENUM types and adds them to schema
func (g *Generator) extractInlineEnums() map[string]string {
	enumTypeMap := make(map[string]string)

	if g.schema == nil {
		return enumTypeMap
	}

	for _, table := range g.schema.Tables {
		for _, col := range table.Columns {
			colTypeLower := strings.ToLower(col.Type)
			if strings.HasPrefix(colTypeLower, "enum(") {
				values := extractEnumValues(col.Type)
				if len(values) > 0 {
					enumName := fmt.Sprintf("%s_%s", table.Name, col.Name)

					enumTypeMap[colTypeLower] = enumName

					g.schema.Enums = append(g.schema.Enums, &parser.Enum{
						Name:   enumName,
						Values: values,
					})
				}
			}
		}
	}

	return enumTypeMap
}

// extractEnumValues extracts values from inline ENUM type
func extractEnumValues(columnType string) []string {
	columnType = strings.ToLower(columnType)
	if !strings.HasPrefix(columnType, "enum(") {
		return nil
	}

	values := strings.TrimPrefix(columnType, "enum(")
	values = strings.TrimSuffix(values, ")")

	var result []string
	parts := strings.Split(values, ",")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		part = strings.Trim(part, "'\"")
		if part != "" {
			result = append(result, part)
		}
	}

	return result
}
