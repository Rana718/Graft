package gogen

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/Rana718/Graft/internal/config"
	"github.com/Rana718/Graft/internal/jsgen"
)

type Generator struct {
	Config      *config.Config
	insertRegex *regexp.Regexp
	updateRegex *regexp.Regexp
	deleteRegex *regexp.Regexp
	schema      *jsgen.Schema
	jsParser    *jsgen.Generator
}

func New(cfg *config.Config) *Generator {
	return &Generator{
		Config:      cfg,
		insertRegex: regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`),
		updateRegex: regexp.MustCompile(`(?i)UPDATE\s+(\w+)`),
		deleteRegex: regexp.MustCompile(`(?i)DELETE\s+FROM\s+(\w+)`),
		jsParser:    jsgen.New(cfg),
	}
}

func (g *Generator) Generate() error {
	if err := os.MkdirAll("graft_gen", 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Use jsgen parser functions
	schema, err := g.jsParser.ParseSchema()
	if err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}
	g.schema = schema

	queries, err := g.jsParser.ParseQueries(schema)
	if err != nil {
		return fmt.Errorf("failed to parse queries: %w", err)
	}

	if err := g.generateModels(); err != nil {
		return err
	}

	if err := g.generateDB(); err != nil {
		return err
	}

	if err := g.generateQueries(queries); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateModels() error {
	var code strings.Builder

	code.WriteString("// Code generated by Graft. DO NOT EDIT.\n\n")
	code.WriteString("package graft\n\n")
	code.WriteString("import (\n")
	code.WriteString("\t\"database/sql\"\n")
	code.WriteString("\t\"time\"\n")
	code.WriteString(")\n\n")

	// Generate enums
	for _, enum := range g.schema.Enums {
		enumName := toPascalCase(enum.Name)
		code.WriteString(fmt.Sprintf("type %s string\n\n", enumName))
		code.WriteString("const (\n")
		for _, val := range enum.Values {
			constName := fmt.Sprintf("%s%s", enumName, toPascalCase(val))
			code.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, enumName, val))
		}
		code.WriteString(")\n\n")
	}

	// Generate table models
	for _, table := range g.schema.Tables {
		structName := toPascalCase(table.Name)
		code.WriteString(fmt.Sprintf("type %s struct {\n", structName))
		for _, col := range table.Columns {
			fieldName := toPascalCase(col.Name)
			goType := g.mapSQLTypeToGo(col.Type, col.Nullable)
			jsonTag := toSnakeCase(col.Name)
			code.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\" db:\"%s\"`\n", fieldName, goType, jsonTag, col.Name))
		}
		code.WriteString("}\n\n")
	}

	modelsPath := filepath.Join("graft_gen", "models.go")
	return os.WriteFile(modelsPath, []byte(code.String()), 0644)
}

func (g *Generator) generateDB() error {
	var code strings.Builder

	code.WriteString("// Code generated by Graft. DO NOT EDIT.\n\n")
	code.WriteString("package graft\n\n")
	code.WriteString("import (\n")
	code.WriteString("\t\"database/sql\"\n")
	code.WriteString(")\n\n")
	code.WriteString("type DBTX interface {\n")
	code.WriteString("\tExec(query string, args ...interface{}) (sql.Result, error)\n")
	code.WriteString("\tPrepare(query string) (*sql.Stmt, error)\n")
	code.WriteString("\tQuery(query string, args ...interface{}) (*sql.Rows, error)\n")
	code.WriteString("\tQueryRow(query string, args ...interface{}) *sql.Row\n")
	code.WriteString("}\n\n")
	code.WriteString("func New(db DBTX) *Queries {\n")
	code.WriteString("\treturn &Queries{db: db}\n")
	code.WriteString("}\n\n")
	code.WriteString("type Queries struct {\n")
	code.WriteString("\tdb DBTX\n")
	code.WriteString("}\n\n")

	dbPath := filepath.Join("graft_gen", "db.go")
	return os.WriteFile(dbPath, []byte(code.String()), 0644)
}

func (g *Generator) generateQueries(queries []*jsgen.Query) error {
	// Group queries by source file
	queryGroups := make(map[string][]*jsgen.Query)
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries" // fallback for queries without source file
		}
		queryGroups[sourceFile] = append(queryGroups[sourceFile], query)
	}

	// Track used filenames to handle duplicates
	usedNames := make(map[string]int)

	// Generate a separate file for each SQL file
	for sourceFile, fileQueries := range queryGroups {
		var code strings.Builder

		code.WriteString("// Code generated by Graft. DO NOT EDIT.\n\n")
		code.WriteString("package graft\n\n")

		// Detect required imports by analyzing queries
		needsTime := false
		needsSQL := false

		for _, query := range fileQueries {
			// Check if any column uses time.Time
			for _, col := range query.Columns {
				colType := g.mapColumnTypeToGo(col.Type, col.Nullable)
				if strings.Contains(colType, "time.Time") {
					needsTime = true
				}
				if strings.Contains(colType, "sql.Null") {
					needsSQL = true
				}
			}
			// sql.ErrNoRows is always used for :one queries
			if strings.ToLower(query.Cmd) == ":one" {
				needsSQL = true
			}
		}

		// Write imports
		imports := []string{}
		if needsSQL {
			imports = append(imports, "\"database/sql\"")
		}
		if needsTime {
			imports = append(imports, "\"time\"")
		}

		if len(imports) > 0 {
			code.WriteString("import (\n")
			for _, imp := range imports {
				code.WriteString(fmt.Sprintf("\t%s\n", imp))
			}
			code.WriteString(")\n\n")
		}

		for _, query := range fileQueries {
			if err := g.generateQueryMethod(&code, query); err != nil {
				return err
			}
		}

		// Output file name: remove .sql extension, handle duplicates
		baseName := strings.TrimSuffix(sourceFile, ".sql")
		outputFile := baseName + ".go"

		// Handle duplicate names
		if count, exists := usedNames[baseName]; exists {
			usedNames[baseName] = count + 1
			outputFile = fmt.Sprintf("%s_%d.go", baseName, count+1)
		} else {
			usedNames[baseName] = 1
		}

		queriesPath := filepath.Join("graft_gen", outputFile)
		if err := os.WriteFile(queriesPath, []byte(code.String()), 0644); err != nil {
			return err
		}
	}

	return nil
}

// expandWildcardColumns expands SELECT * or RETURNING * into actual column list
func (g *Generator) expandWildcardColumns(query *jsgen.Query) []*jsgen.QueryColumn {
	// Check if query has RETURNING clause
	hasReturning := strings.Contains(strings.ToUpper(query.SQL), "RETURNING")

	// If no wildcard and no RETURNING, return original columns
	if len(query.Columns) == 0 {
		if hasReturning {
			// If there's a RETURNING clause but no columns detected, expand based on table
			// Continue to table name extraction
		} else {
			return query.Columns
		}
	} else if len(query.Columns) == 1 && query.Columns[0].Name != "*" {
		return query.Columns
	} else if len(query.Columns) > 1 {
		// Check if any column is wildcard
		hasWildcard := false
		for _, col := range query.Columns {
			if col.Name == "*" {
				hasWildcard = true
				break
			}
		}
		if !hasWildcard {
			return query.Columns
		}
	}

	// Find the table name from the query
	tableName := g.extractTableName(query.SQL)
	if tableName == "" {
		return query.Columns
	}

	// Find the table in schema
	schema, err := g.jsParser.ParseSchema()
	if err != nil {
		return query.Columns
	}

	var table *jsgen.Table
	for _, t := range schema.Tables {
		if strings.EqualFold(t.Name, tableName) {
			table = t
			break
		}
	}

	if table == nil {
		return query.Columns
	}

	// Expand to actual columns
	expanded := make([]*jsgen.QueryColumn, 0, len(table.Columns))
	for _, col := range table.Columns {
		expanded = append(expanded, &jsgen.QueryColumn{
			Name:     col.Name,
			Type:     col.Type,
			Table:    table.Name,
			Nullable: col.Nullable,
		})
	}

	return expanded
}

// extractTableName extracts the table name from INSERT/SELECT/UPDATE query
func (g *Generator) extractTableName(sql string) string {
	sqlUpper := strings.ToUpper(sql)

	// For INSERT queries: INSERT INTO table_name
	if strings.Contains(sqlUpper, "INSERT INTO") {
		re := regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`)
		matches := re.FindStringSubmatch(sql)
		if len(matches) > 1 {
			return matches[1]
		}
	}

	// For SELECT queries: SELECT ... FROM table_name
	if strings.Contains(sqlUpper, "FROM") {
		re := regexp.MustCompile(`(?i)FROM\s+(\w+)`)
		matches := re.FindStringSubmatch(sql)
		if len(matches) > 1 {
			return matches[1]
		}
	}

	// For UPDATE queries: UPDATE table_name
	if strings.Contains(sqlUpper, "UPDATE") {
		re := regexp.MustCompile(`(?i)UPDATE\s+(\w+)`)
		matches := re.FindStringSubmatch(sql)
		if len(matches) > 1 {
			return matches[1]
		}
	}

	return ""
}

func (g *Generator) generateQueryMethod(code *strings.Builder, query *jsgen.Query) error {
	// Expand wildcard columns if needed
	columns := g.expandWildcardColumns(query)

	methodName := toPascalCase(query.Name)

	// Use individual params for simple queries (3 or fewer params)
	// Use struct for complex queries (4+ params)
	useStructParams := len(query.Params) > 3

	// Generate param struct only if using struct params
	if useStructParams && len(query.Params) > 0 {
		code.WriteString(fmt.Sprintf("type %sParams struct {\n", methodName))
		for _, param := range query.Params {
			fieldName := toPascalCase(param.Name)
			goType := g.mapJSTypeToGo(param.Type)
			code.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, toSnakeCase(param.Name)))
		}
		code.WriteString("}\n\n")
	}

	// Determine return type based on command
	cmd := strings.ToLower(query.Cmd)
	isModifying := g.isModifyingQuery(query.SQL)

	// Generate method signature
	code.WriteString(fmt.Sprintf("func (q *Queries) %s(", methodName))

	// Generate parameter list
	if len(query.Params) > 0 {
		if useStructParams {
			code.WriteString(fmt.Sprintf("arg %sParams", methodName))
		} else {
			// Individual parameters
			paramList := []string{}
			for _, param := range query.Params {
				paramName := toSnakeCase(param.Name)
				goType := g.mapJSTypeToGo(param.Type)
				paramList = append(paramList, fmt.Sprintf("%s %s", paramName, goType))
			}
			code.WriteString(strings.Join(paramList, ", "))
		}
	}

	code.WriteString(") (")

	// Determine return type
	switch {
	case cmd == ":one":
		if len(columns) == 1 {
			code.WriteString(fmt.Sprintf("%s, error", g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable)))
		} else {
			code.WriteString(fmt.Sprintf("%sRow, error", methodName))
		}
	case cmd == ":many":
		if len(columns) == 1 {
			code.WriteString(fmt.Sprintf("[]%s, error", g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable)))
		} else {
			code.WriteString(fmt.Sprintf("[]%sRow, error", methodName))
		}
	case cmd == ":exec" || isModifying:
		code.WriteString("error")
	case cmd == ":execresult":
		code.WriteString("sql.Result, error")
	default:
		code.WriteString("error")
	}

	code.WriteString(") {\n")

	// SQL query constant
	cleanSQL := strings.TrimSpace(query.SQL)
	code.WriteString(fmt.Sprintf("\tconst query = `%s`\n", cleanSQL))

	// Build args slice
	if len(query.Params) > 0 {
		code.WriteString("\targs := []interface{}{")
		for i, param := range query.Params {
			if i > 0 {
				code.WriteString(", ")
			}
			if useStructParams {
				code.WriteString(fmt.Sprintf("arg.%s", toPascalCase(param.Name)))
			} else {
				code.WriteString(toSnakeCase(param.Name))
			}
		}
		code.WriteString("}\n")
	}

	// Generate query execution
	switch {
	case cmd == ":one":
		if len(columns) == 0 {
			// No columns detected, return error
			code.WriteString("\n\treturn nil, fmt.Errorf(\"query has no return columns\")\n")
		} else if len(columns) > 1 {
			code.WriteString(fmt.Sprintf("\n\tvar result %sRow\n", methodName))
			code.WriteString("\trows, err := q.db.Query(query")
			if len(query.Params) > 0 {
				code.WriteString(", args...")
			}
			code.WriteString(")\n")
			code.WriteString("\tif err != nil {\n")
			code.WriteString("\t\treturn result, err\n")
			code.WriteString("\t}\n")
			code.WriteString("\tdefer rows.Close()\n")
			code.WriteString("\tif !rows.Next() {\n")
			code.WriteString("\t\tif err := rows.Err(); err != nil {\n")
			code.WriteString("\t\t\treturn result, err\n")
			code.WriteString("\t\t}\n")
			code.WriteString("\t\treturn result, sql.ErrNoRows\n")
			code.WriteString("\t}\n")
			code.WriteString("\terr = rows.Scan(")
			for i, col := range columns {
				if i > 0 {
					code.WriteString(", ")
				}
				code.WriteString(fmt.Sprintf("&result.%s", toPascalCase(col.Name)))
			}
			code.WriteString(")\n")
			code.WriteString("\treturn result, err\n")
		} else {
			code.WriteString("\n\tvar result ")
			code.WriteString(g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable))
			code.WriteString("\n\trows, err := q.db.Query(query")
			if len(query.Params) > 0 {
				code.WriteString(", args...")
			}
			code.WriteString(")\n")
			code.WriteString("\tif err != nil {\n")
			code.WriteString("\t\treturn result, err\n")
			code.WriteString("\t}\n")
			code.WriteString("\tdefer rows.Close()\n")
			code.WriteString("\tif !rows.Next() {\n")
			code.WriteString("\t\tif err := rows.Err(); err != nil {\n")
			code.WriteString("\t\t\treturn result, err\n")
			code.WriteString("\t\t}\n")
			code.WriteString("\t\treturn result, sql.ErrNoRows\n")
			code.WriteString("\t}\n")
			code.WriteString("\terr = rows.Scan(&result)\n")
			code.WriteString("\treturn result, err\n")
		}

	case cmd == ":many":
		if len(columns) == 0 {
			// No columns detected, return error
			code.WriteString("\n\treturn nil, fmt.Errorf(\"query has no return columns\")\n")
		} else {
			code.WriteString("\n\trows, err := q.db.Query(query")
			if len(query.Params) > 0 {
				code.WriteString(", args...")
			}
			code.WriteString(")\n")
			code.WriteString("\tif err != nil {\n")
			code.WriteString("\t\treturn nil, err\n")
			code.WriteString("\t}\n")
			code.WriteString("\tdefer rows.Close()\n\n")

			if len(columns) > 1 {
				code.WriteString(fmt.Sprintf("\tvar items []%sRow\n", methodName))
			} else {
				code.WriteString(fmt.Sprintf("\tvar items []%s\n", g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable)))
			}

			code.WriteString("\tfor rows.Next() {\n")
			if len(columns) > 1 {
				code.WriteString(fmt.Sprintf("\t\tvar item %sRow\n", methodName))
				code.WriteString("\t\tif err := rows.Scan(")
				for i, col := range columns {
					if i > 0 {
						code.WriteString(", ")
					}
					code.WriteString(fmt.Sprintf("&item.%s", toPascalCase(col.Name)))
				}
				code.WriteString("); err != nil {\n")
				code.WriteString("\t\t\treturn nil, err\n")
				code.WriteString("\t\t}\n")
				code.WriteString("\t\titems = append(items, item)\n")
			} else {
				code.WriteString("\t\tvar item ")
				code.WriteString(g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable))
				code.WriteString("\n\t\tif err := rows.Scan(&item); err != nil {\n")
				code.WriteString("\t\t\treturn nil, err\n")
				code.WriteString("\t\t}\n")
				code.WriteString("\t\titems = append(items, item)\n")
			}
			code.WriteString("\t}\n")
			code.WriteString("\treturn items, rows.Err()\n")
		}

	case cmd == ":execresult":
		code.WriteString("\n\treturn q.db.Exec(query")
		if len(query.Params) > 0 {
			code.WriteString(", args...")
		}
		code.WriteString(")\n")

	default: // :exec or modifying
		code.WriteString("\n\t_, err := q.db.Exec(query")
		if len(query.Params) > 0 {
			code.WriteString(", args...")
		}
		code.WriteString(")\n")
		code.WriteString("\treturn err\n")
	}

	code.WriteString("}\n\n")

	// Generate result struct if needed
	if (cmd == ":one" || cmd == ":many") && len(columns) > 1 {
		code.WriteString(fmt.Sprintf("type %sRow struct {\n", methodName))
		for _, col := range columns {
			fieldName := toPascalCase(col.Name)
			goType := g.mapColumnTypeToGo(col.Type, col.Nullable)
			code.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, toSnakeCase(col.Name)))
		}
		code.WriteString("}\n\n")
	}

	return nil
}

func (g *Generator) isModifyingQuery(sql string) bool {
	sqlUpper := strings.ToUpper(sql)
	return containsSQLKeyword(sqlUpper, "INSERT") ||
		containsSQLKeyword(sqlUpper, "UPDATE") ||
		containsSQLKeyword(sqlUpper, "DELETE")
}

func containsSQLKeyword(sql, keyword string) bool {
	pattern := fmt.Sprintf(`\b%s\b`, keyword)
	matched, _ := regexp.MatchString(pattern, sql)
	return matched
}

func (g *Generator) mapSQLTypeToGo(sqlType string, nullable bool) string {
	sqlTypeLower := strings.ToLower(sqlType)

	// Check if it's an enum type
	if g.schema != nil {
		for _, enum := range g.schema.Enums {
			if strings.ToLower(enum.Name) == sqlTypeLower {
				enumType := toPascalCase(enum.Name)
				if nullable {
					return "sql.Null" + enumType
				}
				return enumType
			}
		}
	}

	baseType := ""
	switch {
	case strings.Contains(sqlTypeLower, "int"):
		baseType = "int64"
	case strings.Contains(sqlTypeLower, "serial"):
		baseType = "int64"
	case strings.Contains(sqlTypeLower, "float") || strings.Contains(sqlTypeLower, "double") || strings.Contains(sqlTypeLower, "numeric") || strings.Contains(sqlTypeLower, "decimal"):
		baseType = "float64"
	case strings.Contains(sqlTypeLower, "bool"):
		baseType = "bool"
	case strings.Contains(sqlTypeLower, "time") || strings.Contains(sqlTypeLower, "date"):
		baseType = "time.Time"
	case strings.Contains(sqlTypeLower, "json"):
		baseType = "[]byte"
	case strings.Contains(sqlTypeLower, "uuid"):
		baseType = "string"
	default:
		baseType = "string"
	}

	if nullable {
		switch baseType {
		case "int64":
			return "sql.NullInt64"
		case "float64":
			return "sql.NullFloat64"
		case "bool":
			return "sql.NullBool"
		case "string":
			return "sql.NullString"
		case "time.Time":
			return "sql.NullTime"
		default:
			return "*" + baseType
		}
	}

	return baseType
}

func (g *Generator) mapJSTypeToGo(jsType string) string {
	// Handle union types (e.g., "Date | string")
	if strings.Contains(jsType, "|") {
		// Take the first type for simplicity
		parts := strings.Split(jsType, "|")
		jsType = strings.TrimSpace(parts[0])
	}

	jsTypeLower := strings.ToLower(strings.TrimSpace(jsType))

	// Check if it's a JavaScript type
	switch jsTypeLower {
	case "number":
		return "int64"
	case "string":
		return "string"
	case "boolean", "bool":
		return "bool"
	case "date":
		return "time.Time"
	case "any", "interface{}":
		return "interface{}"
	}

	// If not a JS type, it might be a SQL type - use mapSQLTypeToGo
	if strings.Contains(jsTypeLower, "int") ||
		strings.Contains(jsTypeLower, "serial") ||
		strings.Contains(jsTypeLower, "varchar") ||
		strings.Contains(jsTypeLower, "char") ||
		strings.Contains(jsTypeLower, "text") ||
		strings.Contains(jsTypeLower, "time") ||
		strings.Contains(jsTypeLower, "date") ||
		strings.Contains(jsTypeLower, "float") ||
		strings.Contains(jsTypeLower, "double") ||
		strings.Contains(jsTypeLower, "numeric") ||
		strings.Contains(jsTypeLower, "decimal") ||
		strings.Contains(jsTypeLower, "json") ||
		strings.Contains(jsTypeLower, "uuid") {
		// Default to non-nullable when coming from JS parser
		return g.mapSQLTypeToGo(jsType, false)
	}

	// Check if it's an enum type from schema
	if g.schema != nil {
		for _, enum := range g.schema.Enums {
			if strings.EqualFold(enum.Name, jsType) {
				return toPascalCase(enum.Name)
			}
		}
	}
	return jsType
}

// mapColumnTypeToGo converts column type to Go type, handling nullable types
func (g *Generator) mapColumnTypeToGo(colType string, nullable bool) string {
	typeLower := strings.ToLower(strings.TrimSpace(colType))

	// Check if it's a SQL type
	if strings.Contains(typeLower, "int") ||
		strings.Contains(typeLower, "serial") ||
		strings.Contains(typeLower, "varchar") ||
		strings.Contains(typeLower, "char") ||
		strings.Contains(typeLower, "text") ||
		strings.Contains(typeLower, "time") ||
		strings.Contains(typeLower, "date") ||
		strings.Contains(typeLower, "float") ||
		strings.Contains(typeLower, "double") ||
		strings.Contains(typeLower, "numeric") ||
		strings.Contains(typeLower, "decimal") ||
		strings.Contains(typeLower, "bool") ||
		strings.Contains(typeLower, "json") ||
		strings.Contains(typeLower, "uuid") {
		return g.mapSQLTypeToGo(colType, nullable)
	}

	// Check if it's an enum type from schema
	if g.schema != nil {
		for _, enum := range g.schema.Enums {
			if strings.EqualFold(enum.Name, colType) {
				if nullable {
					return "sql.Null" + toPascalCase(enum.Name)
				}
				return toPascalCase(enum.Name)
			}
		}
	}

	// Default fallback - use mapJSTypeToGo for JS types
	return g.mapJSTypeToGo(colType)
}

func toPascalCase(s string) string {
	words := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || r == ' '
	})
	for i, word := range words {
		words[i] = strings.Title(strings.ToLower(word))
	}
	return strings.Join(words, "")
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}
