package gogen

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/Lumos-Labs-HQ/flash/internal/config"
	"github.com/Lumos-Labs-HQ/flash/internal/parser"
	"github.com/Lumos-Labs-HQ/flash/internal/utils"
)

type Generator struct {
	Config       *config.Config
	insertRegex  *regexp.Regexp
	updateRegex  *regexp.Regexp
	deleteRegex  *regexp.Regexp
	schema       *parser.Schema
	schemaParser *parser.SchemaParser
	queryParser  *parser.QueryParser
}

func New(cfg *config.Config) *Generator {
	return &Generator{
		Config:       cfg,
		insertRegex:  regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`),
		updateRegex:  regexp.MustCompile(`(?i)UPDATE\s+(\w+)`),
		deleteRegex:  regexp.MustCompile(`(?i)DELETE\s+FROM\s+(\w+)`),
		schemaParser: parser.NewSchemaParser(cfg),
		queryParser:  parser.NewQueryParser(cfg),
	}
}

func (g *Generator) Generate() error {
	if err := os.MkdirAll("flash_gen", 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	schema, err := g.schemaParser.Parse()
	if err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}
	g.schema = schema

	queries, err := g.queryParser.Parse(schema)
	if err != nil {
		return fmt.Errorf("failed to parse queries: %w", err)
	}

	if err := g.generateModels(); err != nil {
		return err
	}

	if err := g.generateDB(); err != nil {
		return err
	}

	if err := g.generateQueries(queries); err != nil {
		return err
	}

	return nil
}

func (g *Generator) generateModels() error {
	// Pre-allocate: ~200 bytes header + ~150 bytes per table + ~100 per enum
	estimatedSize := 200 + (len(g.schema.Tables) * 150) + (len(g.schema.Enums) * 100)
	var code strings.Builder
	code.Grow(estimatedSize)

	code.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n\n")
	code.WriteString("package flash_gen\n\n")
	code.WriteString("import (\n")
	code.WriteString("\t\"database/sql\"\n")
	code.WriteString("\t\"time\"\n")
	code.WriteString(")\n\n")

	for _, enum := range g.schema.Enums {
		enumName := utils.ToPascalCase(enum.Name)
		code.WriteString(fmt.Sprintf("type %s string\n\n", enumName))
		code.WriteString("const (\n")
		for _, val := range enum.Values {
			constName := fmt.Sprintf("%s%s", enumName, utils.ToPascalCase(val))
			code.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, enumName, val))
		}
		code.WriteString(")\n\n")
	}

	for _, table := range g.schema.Tables {
		structName := utils.ToPascalCase(table.Name)
		code.WriteString(fmt.Sprintf("type %s struct {\n", structName))
		for _, col := range table.Columns {
			fieldName := utils.ToPascalCase(col.Name)
			goType := g.mapSQLTypeToGo(col.Type, col.Nullable)
			jsonTag := utils.ToSnakeCase(col.Name)
			code.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\" db:\"%s\"`\n", fieldName, goType, jsonTag, col.Name))
		}
		code.WriteString("}\n\n")
	}

	modelsPath := filepath.Join("flash_gen", "models.go")
	return os.WriteFile(modelsPath, []byte(code.String()), 0644)
}

func (g *Generator) generateDB() error {
	// Pre-allocate buffer for DB interface code
	var code strings.Builder
	code.Grow(500)

	code.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n\n")
	code.WriteString("package flash_gen\n\n")
	code.WriteString("import (\n")
	code.WriteString("\t\"database/sql\"\n")
	code.WriteString(")\n\n")
	code.WriteString("type DBTX interface {\n")
	code.WriteString("\tExec(query string, args ...interface{}) (sql.Result, error)\n")
	code.WriteString("\tPrepare(query string) (*sql.Stmt, error)\n")
	code.WriteString("\tQuery(query string, args ...interface{}) (*sql.Rows, error)\n")
	code.WriteString("\tQueryRow(query string, args ...interface{}) *sql.Row\n")
	code.WriteString("}\n\n")
	code.WriteString("func New(db DBTX) *Queries {\n")
	code.WriteString("\treturn &Queries{db: db}\n")
	code.WriteString("}\n\n")
	code.WriteString("type Queries struct {\n")
	code.WriteString("\tdb DBTX\n")
	code.WriteString("}\n\n")

	dbPath := filepath.Join("flash_gen", "db.go")
	return os.WriteFile(dbPath, []byte(code.String()), 0644)
}

func (g *Generator) generateQueries(queries []*parser.Query) error {
	queryGroups := make(map[string][]*parser.Query)
	for _, query := range queries {
		sourceFile := query.SourceFile
		if sourceFile == "" {
			sourceFile = "queries"
		}
		queryGroups[sourceFile] = append(queryGroups[sourceFile], query)
	}

	usedNames := make(map[string]int)

	for sourceFile, fileQueries := range queryGroups {
		// Pre-allocate: ~150 bytes header + ~300 bytes per query
		estimatedSize := 150 + (len(fileQueries) * 300)
		var code strings.Builder
		code.Grow(estimatedSize)

		code.WriteString("// Code generated by FlashORM. DO NOT EDIT.\n\n")
		code.WriteString("package flash_gen\n\n")

		needsTime := false
		needsSQL := false

		for _, query := range fileQueries {
			for _, col := range query.Columns {
				colType := g.mapColumnTypeToGo(col.Type, col.Nullable)
				if strings.Contains(colType, "time.Time") {
					needsTime = true
				}
				if strings.Contains(colType, "sql.Null") {
					needsSQL = true
				}
			}
			if strings.ToLower(query.Cmd) == ":one" {
				needsSQL = true
			}
		}

		imports := []string{}
		if needsSQL {
			imports = append(imports, "\"database/sql\"")
		}
		if needsTime {
			imports = append(imports, "\"time\"")
		}

		if len(imports) > 0 {
			code.WriteString("import (\n")
			for _, imp := range imports {
				code.WriteString(fmt.Sprintf("\t%s\n", imp))
			}
			code.WriteString(")\n\n")
		}

		for _, query := range fileQueries {
			if err := g.generateQueryMethod(&code, query); err != nil {
				return err
			}
		}

		baseName := strings.TrimSuffix(sourceFile, ".sql")
		outputFile := baseName + ".go"

		if count, exists := usedNames[baseName]; exists {
			usedNames[baseName] = count + 1
			outputFile = fmt.Sprintf("%s_%d.go", baseName, count+1)
		} else {
			usedNames[baseName] = 1
		}

		queriesPath := filepath.Join("flash_gen", outputFile)
		if err := os.WriteFile(queriesPath, []byte(code.String()), 0644); err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) expandWildcardColumns(query *parser.Query) []*parser.QueryColumn {
	hasReturning := strings.Contains(strings.ToUpper(query.SQL), "RETURNING")

	if len(query.Columns) == 0 {
		if hasReturning {
		} else {
			return query.Columns
		}
	} else if len(query.Columns) == 1 && query.Columns[0].Name != "*" {
		return query.Columns
	} else if len(query.Columns) > 1 {
		hasWildcard := false
		for _, col := range query.Columns {
			if col.Name == "*" {
				hasWildcard = true
				break
			}
		}
		if !hasWildcard {
			return query.Columns
		}
	}

	tableName := g.extractTableName(query.SQL)
	if tableName == "" {
		return query.Columns
	}

	var table *parser.Table
	for _, t := range g.schema.Tables {
		if strings.EqualFold(t.Name, tableName) {
			table = t
			break
		}
	}

	if table == nil {
		return query.Columns
	}

	expanded := make([]*parser.QueryColumn, 0, len(table.Columns))
	for _, col := range table.Columns {
		expanded = append(expanded, &parser.QueryColumn{
			Name:     col.Name,
			Type:     col.Type,
			Table:    table.Name,
			Nullable: col.Nullable,
		})
	}

	return expanded
}

func (g *Generator) extractTableName(sql string) string {
	sqlUpper := strings.ToUpper(sql)

	if strings.Contains(sqlUpper, "INSERT INTO") {
		re := regexp.MustCompile(`(?i)INSERT\s+INTO\s+(\w+)`)
		matches := re.FindStringSubmatch(sql)
		if len(matches) > 1 {
			return matches[1]
		}
	}

	if strings.Contains(sqlUpper, "FROM") {
		re := regexp.MustCompile(`(?i)FROM\s+(\w+)`)
		matches := re.FindStringSubmatch(sql)
		if len(matches) > 1 {
			return matches[1]
		}
	}

	if strings.Contains(sqlUpper, "UPDATE") {
		re := regexp.MustCompile(`(?i)UPDATE\s+(\w+)`)
		matches := re.FindStringSubmatch(sql)
		if len(matches) > 1 {
			return matches[1]
		}
	}

	return ""
}

func (g *Generator) generateQueryMethod(code *strings.Builder, query *parser.Query) error {
	columns := g.expandWildcardColumns(query)

	methodName := utils.ToPascalCase(query.Name)

	useStructParams := len(query.Params) > 3

	if useStructParams && len(query.Params) > 0 {
		code.WriteString(fmt.Sprintf("type %sParams struct {\n", methodName))
		for _, param := range query.Params {
			fieldName := utils.ToPascalCase(param.Name)
			goType := g.mapParamTypeToGo(param.Type)
			code.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, utils.ToSnakeCase(param.Name)))
		}
		code.WriteString("}\n\n")
	}

	cmd := strings.ToLower(query.Cmd)
	isModifying := g.isModifyingQuery(query.SQL)

	code.WriteString(fmt.Sprintf("func (q *Queries) %s(", methodName))

	if len(query.Params) > 0 {
		if useStructParams {
			code.WriteString(fmt.Sprintf("arg %sParams", methodName))
		} else {
			paramList := []string{}
			for _, param := range query.Params {
				paramName := utils.ToSnakeCase(param.Name)
				goType := g.mapParamTypeToGo(param.Type)
				paramList = append(paramList, fmt.Sprintf("%s %s", paramName, goType))
			}
			code.WriteString(strings.Join(paramList, ", "))
		}
	}

	code.WriteString(") (")

	switch {
	case cmd == ":one":
		if len(columns) == 1 {
			code.WriteString(fmt.Sprintf("%s, error", g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable)))
		} else {
			code.WriteString(fmt.Sprintf("%sRow, error", methodName))
		}
	case cmd == ":many":
		if len(columns) == 1 {
			code.WriteString(fmt.Sprintf("[]%s, error", g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable)))
		} else {
			code.WriteString(fmt.Sprintf("[]%sRow, error", methodName))
		}
	case cmd == ":exec" || isModifying:
		code.WriteString("error")
	case cmd == ":execresult":
		code.WriteString("sql.Result, error")
	default:
		code.WriteString("error")
	}

	code.WriteString(") {\n")

	cleanSQL := strings.TrimSpace(query.SQL)
	code.WriteString(fmt.Sprintf("\tconst query = `%s`\n", cleanSQL))

	if len(query.Params) > 0 {
		code.WriteString("\targs := []interface{}{")
		for i, param := range query.Params {
			if i > 0 {
				code.WriteString(", ")
			}
			if useStructParams {
				code.WriteString(fmt.Sprintf("arg.%s", utils.ToPascalCase(param.Name)))
			} else {
				code.WriteString(utils.ToSnakeCase(param.Name))
			}
		}
		code.WriteString("}\n")
	}

	switch {
	case cmd == ":one":
		if len(columns) == 0 {
			code.WriteString("\n\treturn nil, fmt.Errorf(\"query has no return columns\")\n")
		} else if len(columns) > 1 {
			code.WriteString(fmt.Sprintf("\n\tvar result %sRow\n", methodName))
			code.WriteString("\trows, err := q.db.Query(query")
			if len(query.Params) > 0 {
				code.WriteString(", args...")
			}
			code.WriteString(")\n")
			code.WriteString("\tif err != nil {\n")
			code.WriteString("\t\treturn result, err\n")
			code.WriteString("\t}\n")
			code.WriteString("\tdefer rows.Close()\n")
			code.WriteString("\tif !rows.Next() {\n")
			code.WriteString("\t\tif err := rows.Err(); err != nil {\n")
			code.WriteString("\t\t\treturn result, err\n")
			code.WriteString("\t\t}\n")
			code.WriteString("\t\treturn result, sql.ErrNoRows\n")
			code.WriteString("\t}\n")
			code.WriteString("\terr = rows.Scan(")
			for i, col := range columns {
				if i > 0 {
					code.WriteString(", ")
				}
				code.WriteString(fmt.Sprintf("&result.%s", utils.ToPascalCase(col.Name)))
			}
			code.WriteString(")\n")
			code.WriteString("\treturn result, err\n")
		} else {
			code.WriteString("\n\tvar result ")
			code.WriteString(g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable))
			code.WriteString("\n\trows, err := q.db.Query(query")
			if len(query.Params) > 0 {
				code.WriteString(", args...")
			}
			code.WriteString(")\n")
			code.WriteString("\tif err != nil {\n")
			code.WriteString("\t\treturn result, err\n")
			code.WriteString("\t}\n")
			code.WriteString("\tdefer rows.Close()\n")
			code.WriteString("\tif !rows.Next() {\n")
			code.WriteString("\t\tif err := rows.Err(); err != nil {\n")
			code.WriteString("\t\t\treturn result, err\n")
			code.WriteString("\t\t}\n")
			code.WriteString("\t\treturn result, sql.ErrNoRows\n")
			code.WriteString("\t}\n")
			code.WriteString("\terr = rows.Scan(&result)\n")
			code.WriteString("\treturn result, err\n")
		}

	case cmd == ":many":
		if len(columns) == 0 {
			code.WriteString("\n\treturn nil, fmt.Errorf(\"query has no return columns\")\n")
		} else {
			code.WriteString("\n\trows, err := q.db.Query(query")
			if len(query.Params) > 0 {
				code.WriteString(", args...")
			}
			code.WriteString(")\n")
			code.WriteString("\tif err != nil {\n")
			code.WriteString("\t\treturn nil, err\n")
			code.WriteString("\t}\n")
			code.WriteString("\tdefer rows.Close()\n\n")

			if len(columns) > 1 {
				code.WriteString(fmt.Sprintf("\tvar items []%sRow\n", methodName))
			} else {
				code.WriteString(fmt.Sprintf("\tvar items []%s\n", g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable)))
			}

			code.WriteString("\tfor rows.Next() {\n")
			if len(columns) > 1 {
				code.WriteString(fmt.Sprintf("\t\tvar item %sRow\n", methodName))
				code.WriteString("\t\tif err := rows.Scan(")
				for i, col := range columns {
					if i > 0 {
						code.WriteString(", ")
					}
					code.WriteString(fmt.Sprintf("&item.%s", utils.ToPascalCase(col.Name)))
				}
				code.WriteString("); err != nil {\n")
				code.WriteString("\t\t\treturn nil, err\n")
				code.WriteString("\t\t}\n")
				code.WriteString("\t\titems = append(items, item)\n")
			} else {
				code.WriteString("\t\tvar item ")
				code.WriteString(g.mapColumnTypeToGo(columns[0].Type, columns[0].Nullable))
				code.WriteString("\n\t\tif err := rows.Scan(&item); err != nil {\n")
				code.WriteString("\t\t\treturn nil, err\n")
				code.WriteString("\t\t}\n")
				code.WriteString("\t\titems = append(items, item)\n")
			}
			code.WriteString("\t}\n")
			code.WriteString("\treturn items, rows.Err()\n")
		}

	case cmd == ":execresult":
		code.WriteString("\n\treturn q.db.Exec(query")
		if len(query.Params) > 0 {
			code.WriteString(", args...")
		}
		code.WriteString(")\n")

	default:
		code.WriteString("\n\t_, err := q.db.Exec(query")
		if len(query.Params) > 0 {
			code.WriteString(", args...")
		}
		code.WriteString(")\n")
		code.WriteString("\treturn err\n")
	}

	code.WriteString("}\n\n")

	if (cmd == ":one" || cmd == ":many") && len(columns) > 1 {
		code.WriteString(fmt.Sprintf("type %sRow struct {\n", methodName))
		for _, col := range columns {
			fieldName := utils.ToPascalCase(col.Name)
			goType := g.mapColumnTypeToGo(col.Type, col.Nullable)
			code.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, utils.ToSnakeCase(col.Name)))
		}
		code.WriteString("}\n\n")
	}

	return nil
}

func (g *Generator) isModifyingQuery(sql string) bool {
	sqlUpper := strings.ToUpper(sql)
	pattern := `\b(INSERT|UPDATE|DELETE)\b`
	matched, _ := regexp.MatchString(pattern, sqlUpper)
	return matched
}

func (g *Generator) mapSQLTypeToGo(sqlType string, nullable bool) string {
	sqlTypeLower := strings.ToLower(sqlType)

	if g.schema != nil {
		for _, enum := range g.schema.Enums {
			if strings.ToLower(enum.Name) == sqlTypeLower {
				enumType := utils.ToPascalCase(enum.Name)
				if nullable {
					return "sql.Null" + enumType
				}
				return enumType
			}
		}
	}

	baseType := ""
	switch {
	case strings.Contains(sqlTypeLower, "int"):
		baseType = "int64"
	case strings.Contains(sqlTypeLower, "serial"):
		baseType = "int64"
	case strings.Contains(sqlTypeLower, "float") || strings.Contains(sqlTypeLower, "double") || strings.Contains(sqlTypeLower, "numeric") || strings.Contains(sqlTypeLower, "decimal"):
		baseType = "float64"
	case strings.Contains(sqlTypeLower, "bool"):
		baseType = "bool"
	case strings.Contains(sqlTypeLower, "time") || strings.Contains(sqlTypeLower, "date"):
		baseType = "time.Time"
	case strings.Contains(sqlTypeLower, "json"):
		baseType = "[]byte"
	case strings.Contains(sqlTypeLower, "uuid"):
		baseType = "string"
	default:
		baseType = "string"
	}

	if nullable {
		switch baseType {
		case "int64":
			return "sql.NullInt64"
		case "float64":
			return "sql.NullFloat64"
		case "bool":
			return "sql.NullBool"
		case "string":
			return "sql.NullString"
		case "time.Time":
			return "sql.NullTime"
		default:
			return "*" + baseType
		}
	}

	return baseType
}

func (g *Generator) mapParamTypeToGo(paramType string) string {
	// Handle union types (e.g., for enums defined in queries)
	if strings.Contains(paramType, "|") {
		parts := strings.Split(paramType, "|")
		paramType = strings.TrimSpace(parts[0])
	}

	// Check if it's an enum type
	if g.schema != nil {
		for _, enum := range g.schema.Enums {
			if strings.EqualFold(enum.Name, paramType) {
				return utils.ToPascalCase(enum.Name)
			}
		}
	}

	// Map SQL types to Go types (non-nullable for parameters)
	return g.mapSQLTypeToGo(paramType, false)
}

func (g *Generator) mapColumnTypeToGo(colType string, nullable bool) string {
	// Simply delegate to the main SQL type mapper
	return g.mapSQLTypeToGo(colType, nullable)
}
