// Code generated by Graft. DO NOT EDIT.

package graft_gen

import (
	"database/sql"
	"time"
)

func (q *Queries) Createuser(name string, email string) (CreateuserRow, error) {
	const query = `INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *;`
	args := []interface{}{name, email}

	var result CreateuserRow
	rows, err := q.db.Query(query, args...)
	if err != nil {
		return result, err
	}
	defer rows.Close()
	if !rows.Next() {
		if err := rows.Err(); err != nil {
			return result, err
		}
		return result, sql.ErrNoRows
	}
	err = rows.Scan(&result.Id, &result.Name, &result.Address, &result.Isadmin, &result.Email, &result.CreatedAt, &result.UpdatedAt, &result.Role)
	return result, err
}

type CreateuserRow struct {
	Id int64 `json:"id"`
	Name string `json:"name"`
	Address sql.NullString `json:"address"`
	Isadmin bool `json:"isadmin"`
	Email string `json:"email"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Role UserRole `json:"role"`
}

func (q *Queries) Getuser(id int64) (GetuserRow, error) {
	const query = `SELECT * FROM users WHERE id = $1;`
	args := []interface{}{id}

	var result GetuserRow
	rows, err := q.db.Query(query, args...)
	if err != nil {
		return result, err
	}
	defer rows.Close()
	if !rows.Next() {
		if err := rows.Err(); err != nil {
			return result, err
		}
		return result, sql.ErrNoRows
	}
	err = rows.Scan(&result.Id, &result.Name, &result.Address, &result.Isadmin, &result.Email, &result.CreatedAt, &result.UpdatedAt, &result.Role)
	return result, err
}

type GetuserRow struct {
	Id int64 `json:"id"`
	Name string `json:"name"`
	Address sql.NullString `json:"address"`
	Isadmin bool `json:"isadmin"`
	Email string `json:"email"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Role UserRole `json:"role"`
}

func (q *Queries) Getuserbyemail(email string) (GetuserbyemailRow, error) {
	const query = `SELECT * FROM users WHERE email = $1;`
	args := []interface{}{email}

	var result GetuserbyemailRow
	rows, err := q.db.Query(query, args...)
	if err != nil {
		return result, err
	}
	defer rows.Close()
	if !rows.Next() {
		if err := rows.Err(); err != nil {
			return result, err
		}
		return result, sql.ErrNoRows
	}
	err = rows.Scan(&result.Id, &result.Name, &result.Address, &result.Isadmin, &result.Email, &result.CreatedAt, &result.UpdatedAt, &result.Role)
	return result, err
}

type GetuserbyemailRow struct {
	Id int64 `json:"id"`
	Name string `json:"name"`
	Address sql.NullString `json:"address"`
	Isadmin bool `json:"isadmin"`
	Email string `json:"email"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Role UserRole `json:"role"`
}

func (q *Queries) Createcategory(name string) (CreatecategoryRow, error) {
	const query = `INSERT INTO categories (name) VALUES ($1) RETURNING *;`
	args := []interface{}{name}

	var result CreatecategoryRow
	rows, err := q.db.Query(query, args...)
	if err != nil {
		return result, err
	}
	defer rows.Close()
	if !rows.Next() {
		if err := rows.Err(); err != nil {
			return result, err
		}
		return result, sql.ErrNoRows
	}
	err = rows.Scan(&result.Id, &result.Name, &result.CreatedAt)
	return result, err
}

type CreatecategoryRow struct {
	Id int64 `json:"id"`
	Name string `json:"name"`
	CreatedAt time.Time `json:"created_at"`
}

type CreatepostParams struct {
	UserId int64 `json:"user_id"`
	CategoryId int64 `json:"category_id"`
	Title string `json:"title"`
	Content string `json:"content"`
}

func (q *Queries) Createpost(arg CreatepostParams) (CreatepostRow, error) {
	const query = `INSERT INTO posts (user_id, category_id, title, content) VALUES ($1, $2, $3, $4) RETURNING *;`
	args := []interface{}{arg.UserId, arg.CategoryId, arg.Title, arg.Content}

	var result CreatepostRow
	rows, err := q.db.Query(query, args...)
	if err != nil {
		return result, err
	}
	defer rows.Close()
	if !rows.Next() {
		if err := rows.Err(); err != nil {
			return result, err
		}
		return result, sql.ErrNoRows
	}
	err = rows.Scan(&result.Id, &result.UserId, &result.CategoryId, &result.Title, &result.Content, &result.CreatedAt, &result.UpdatedAt, &result.Status)
	return result, err
}

type CreatepostRow struct {
	Id int64 `json:"id"`
	UserId int64 `json:"user_id"`
	CategoryId int64 `json:"category_id"`
	Title string `json:"title"`
	Content string `json:"content"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Status PostStatus `json:"status"`
}

func (q *Queries) Createcomment(post_id int64, user_id int64, content string) (CreatecommentRow, error) {
	const query = `INSERT INTO comments (post_id, user_id, content) VALUES ($1, $2, $3) RETURNING *;`
	args := []interface{}{post_id, user_id, content}

	var result CreatecommentRow
	rows, err := q.db.Query(query, args...)
	if err != nil {
		return result, err
	}
	defer rows.Close()
	if !rows.Next() {
		if err := rows.Err(); err != nil {
			return result, err
		}
		return result, sql.ErrNoRows
	}
	err = rows.Scan(&result.Id, &result.PostId, &result.UserId, &result.Content, &result.CreatedAt)
	return result, err
}

type CreatecommentRow struct {
	Id int64 `json:"id"`
	PostId int64 `json:"post_id"`
	UserId int64 `json:"user_id"`
	Content string `json:"content"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) Getpostwithcomments(id int64) ([]GetpostwithcommentsRow, error) {
	const query = `SELECT p.id AS post_id, p.title, p.content, u.name AS author, c.content AS comment_text, cu.name AS commenter FROM posts p JOIN users u ON p.user_id = u.id LEFT JOIN comments c ON p.id = c.post_id LEFT JOIN users cu ON c.user_id = cu.id WHERE p.id = $1;`
	args := []interface{}{id}

	rows, err := q.db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var items []GetpostwithcommentsRow
	for rows.Next() {
		var item GetpostwithcommentsRow
		if err := rows.Scan(&item.PostId, &item.Title, &item.Content, &item.Author, &item.CommentText, &item.Commenter); err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	return items, rows.Err()
}

type GetpostwithcommentsRow struct {
	PostId string `json:"post_id"`
	Title string `json:"title"`
	Content string `json:"content"`
	Author string `json:"author"`
	CommentText string `json:"comment_text"`
	Commenter string `json:"commenter"`
}

func (q *Queries) Getpostdetailswithallrelations(id int64) (GetpostdetailswithallrelationsRow, error) {
	const query = `SELECT p.id, p.title, p.content, p.status, p.created_at, p.updated_at, u.id as author_id, u.name as author_name, u.email as author_email, u.role as author_role, u.isadmin as author_is_admin, cat.id as category_id, cat.name as category_name, COUNT(DISTINCT c.id) as comment_count, COUNT(DISTINCT c.user_id) as unique_commenters, STRING_AGG(DISTINCT c.content, ' | ' ORDER BY c.content) as all_comments, ARRAY_AGG(DISTINCT cu.name ORDER BY cu.name) as commenter_names, MAX(c.created_at) as last_comment_date, LENGTH(p.content) as content_length, EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600 as hours_since_created FROM posts p INNER JOIN users u ON p.user_id = u.id INNER JOIN categories cat ON p.category_id = cat.id LEFT JOIN comments c ON p.id = c.post_id LEFT JOIN users cu ON c.user_id = cu.id WHERE p.id = $1 GROUP BY p.id, p.title, p.content, p.status, p.created_at, p.updated_at, u.id, u.name, u.email, u.role, u.isadmin, cat.id, cat.name;`
	args := []interface{}{id}

	var result GetpostdetailswithallrelationsRow
	rows, err := q.db.Query(query, args...)
	if err != nil {
		return result, err
	}
	defer rows.Close()
	if !rows.Next() {
		if err := rows.Err(); err != nil {
			return result, err
		}
		return result, sql.ErrNoRows
	}
	err = rows.Scan(&result.Id, &result.Title, &result.Content, &result.Status, &result.CreatedAt, &result.UpdatedAt, &result.AuthorId, &result.AuthorName, &result.AuthorEmail, &result.AuthorRole, &result.AuthorIsAdmin, &result.CategoryId, &result.CategoryName, &result.CommentCount, &result.UniqueCommenters, &result.AllComments, &result.CommenterNames, &result.LastCommentDate, &result.ContentLength, &result.HoursSinceCreated)
	return result, err
}

type GetpostdetailswithallrelationsRow struct {
	Id int64 `json:"id"`
	Title string `json:"title"`
	Content string `json:"content"`
	Status PostStatus `json:"status"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	AuthorId string `json:"author_id"`
	AuthorName string `json:"author_name"`
	AuthorEmail string `json:"author_email"`
	AuthorRole string `json:"author_role"`
	AuthorIsAdmin string `json:"author_is_admin"`
	CategoryId int64 `json:"category_id"`
	CategoryName string `json:"category_name"`
	CommentCount string `json:"comment_count"`
	UniqueCommenters string `json:"unique_commenters"`
	AllComments string `json:"all_comments"`
	CommenterNames string `json:"commenter_names"`
	LastCommentDate string `json:"last_comment_date"`
	ContentLength string `json:"content_length"`
	HoursSinceCreated string `json:"hours_since_created"`
}

