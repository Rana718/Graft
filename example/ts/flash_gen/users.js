// Code generated by FlashORM. DO NOT EDIT.

class Queries {
  constructor(db) {
    this.db = db;
    this._stmts = new Map();
  }

  async getUserEmail(id) {
    let stmt = this._stmts.get('getUserEmail');
    if (!stmt) {
      stmt = { name: 'getUserEmail', text: `SELECT email FROM users WHERE id = $1 LIMIT 1;` };
      this._stmts.set('getUserEmail', stmt);
    }
    stmt.values = [id];
    const r = await this.db.query(stmt);
    return r.rows[0] ? r.rows[0].email : null;
  }

  async getUserName(id) {
    let stmt = this._stmts.get('getUserName');
    if (!stmt) {
      stmt = { name: 'getUserName', text: `SELECT name FROM users WHERE id = $1 LIMIT 1;` };
      this._stmts.set('getUserName', stmt);
    }
    stmt.values = [id];
    const r = await this.db.query(stmt);
    return r.rows[0] ? r.rows[0].name : null;
  }

  async getUserByEmail(email) {
    let stmt = this._stmts.get('getUserByEmail');
    if (!stmt) {
      stmt = `SELECT * FROM users WHERE email = $1 LIMIT 1;`;
      this._stmts.set('getUserByEmail', stmt);
    }
    const r = await this.db.query(stmt, [email]);
    return r.rows[0] || null;
  }

  async getActiveUsersWithStats() {
    let stmt = this._stmts.get('getActiveUsersWithStats');
    if (!stmt) {
      stmt = { name: 'getActiveUsersWithStats', text: `WITH post_stats AS ( SELECT user_id, COUNT(*) as total_posts, MAX(created_at) as last_post_date FROM posts GROUP BY user_id ), comment_stats AS ( SELECT user_id, COUNT(*) as total_comments FROM comments GROUP BY user_id ) SELECT u.id, u.name, u.email, u.isadmin, ps.total_posts, COALESCE(cs.total_comments, 0) as total_comments, ps.last_post_date FROM users u INNER JOIN post_stats ps ON u.id = ps.user_id LEFT JOIN comment_stats cs ON u.id = cs.user_id ORDER BY ps.total_posts DESC;` };
      this._stmts.set('getActiveUsersWithStats', stmt);
    }
    const r = await this.db.query(stmt);
    return r.rows;
  }

  async getTopActiveUsers() {
    let stmt = this._stmts.get('getTopActiveUsers');
    if (!stmt) {
      stmt = { name: 'getTopActiveUsers', text: `WITH ranked_users AS ( SELECT user_id, COUNT(*) as total_posts FROM posts GROUP BY user_id ORDER BY total_posts DESC LIMIT 10 ) SELECT u.id, u.name, u.email, ru.total_posts, COALESCE(cs.total_comments, 0) as total_comments FROM ranked_users ru INNER JOIN users u ON u.id = ru.user_id LEFT JOIN ( SELECT user_id, COUNT(*) as total_comments FROM comments WHERE user_id IN (SELECT user_id FROM ranked_users) GROUP BY user_id ) cs ON u.id = cs.user_id ORDER BY ru.total_posts DESC;` };
      this._stmts.set('getTopActiveUsers', stmt);
    }
    const r = await this.db.query(stmt);
    return r.rows;
  }

  async createUser(name, email, address, isadmin) {
    let stmt = this._stmts.get('createUser');
    if (!stmt) {
      stmt = `INSERT INTO users (name, email, address, isadmin) VALUES ($1, $2, $3, $4);`;
      this._stmts.set('createUser', stmt);
    }
    const r = await this.db.query(stmt, [name, email, address, isadmin]);
    return r.rowCount;
  }

  async createPost(user_id, category_id, title, content) {
    let stmt = this._stmts.get('createPost');
    if (!stmt) {
      stmt = `INSERT INTO posts (user_id, category_id, title, content) VALUES ($1, $2, $3, $4);`;
      this._stmts.set('createPost', stmt);
    }
    const r = await this.db.query(stmt, [user_id, category_id, title, content]);
    return r.rowCount;
  }

  async createComment(post_id, user_id, content) {
    let stmt = this._stmts.get('createComment');
    if (!stmt) {
      stmt = `INSERT INTO comments (post_id, user_id, content) VALUES ($1, $2, $3);`;
      this._stmts.set('createComment', stmt);
    }
    const r = await this.db.query(stmt, [post_id, user_id, content]);
    return r.rowCount;
  }

  async createCategory(user_id) {
    let stmt = this._stmts.get('createCategory');
    if (!stmt) {
      stmt = `INSERT INTO categories (name) VALUES ($1); SELECT p.id, p.title, p.content, p.created_at, 'post' as activity_type FROM posts p WHERE p.user_id = $1 UNION ALL SELECT c.id, 'Comment' as title, c.content, c.created_at, 'comment' as activity_type FROM comments c WHERE c.user_id = $1 ORDER BY created_at DESC LIMIT 20;`;
      this._stmts.set('createCategory', stmt);
    }
    const r = await this.db.query(stmt, [user_id]);
    return r.rowCount;
  }

  async getAveragePostsPerUser() {
    let stmt = this._stmts.get('getAveragePostsPerUser');
    if (!stmt) {
      stmt = { name: 'getAveragePostsPerUser', text: `SELECT AVG(post_count) as avg_posts FROM ( SELECT COUNT(p.id) as post_count FROM users u LEFT JOIN posts p ON u.id = p.user_id GROUP BY u.id ) as user_posts;` };
      this._stmts.set('getAveragePostsPerUser', stmt);
    }
    stmt.values = [];
    const r = await this.db.query(stmt);
    return r.rows[0] ? r.rows[0].avg_posts : null;
  }

  async getMostCommentedPosts(limit) {
    let stmt = this._stmts.get('getMostCommentedPosts');
    if (!stmt) {
      stmt = `SELECT p.id, p.title, u.name as author, COUNT(c.id) as comment_count FROM posts p INNER JOIN users u ON p.user_id = u.id LEFT JOIN comments c ON p.id = c.post_id GROUP BY p.id, p.title, u.name ORDER BY comment_count DESC LIMIT $1;`;
      this._stmts.set('getMostCommentedPosts', stmt);
    }
    const r = await this.db.query(stmt, [limit]);
    return r.rows;
  }

  async checkUserExists(email) {
    let stmt = this._stmts.get('checkUserExists');
    if (!stmt) {
      stmt = { name: 'checkUserExists', text: `SELECT EXISTS(SELECT 1 FROM users WHERE email = $1) as exists;` };
      this._stmts.set('checkUserExists', stmt);
    }
    stmt.values = [email];
    const r = await this.db.query(stmt);
    return r.rows[0] ? r.rows[0].exists : null;
  }

  async getUsersCreatedBetween(created_at_start, created_at_end) {
    let stmt = this._stmts.get('getUsersCreatedBetween');
    if (!stmt) {
      stmt = `SELECT id, name, email, created_at FROM users WHERE created_at BETWEEN $1 AND $2 ORDER BY created_at DESC;`;
      this._stmts.set('getUsersCreatedBetween', stmt);
    }
    const r = await this.db.query(stmt, [created_at_start, created_at_end]);
    return r.rows;
  }

  async updateUserAdminStatus(id, isadmin) {
    let stmt = this._stmts.get('updateUserAdminStatus');
    if (!stmt) {
      stmt = `UPDATE users SET isadmin = $2, updated_at = NOW() WHERE id = $1;`;
      this._stmts.set('updateUserAdminStatus', stmt);
    }
    const r = await this.db.query(stmt, [id, isadmin]);
    return r.rowCount;
  }

  async deleteInactiveUsers(created_at) {
    let stmt = this._stmts.get('deleteInactiveUsers');
    if (!stmt) {
      stmt = `DELETE FROM users WHERE id NOT IN ( SELECT DISTINCT user_id FROM posts UNION SELECT DISTINCT user_id FROM comments ) AND created_at < $1;`;
      this._stmts.set('deleteInactiveUsers', stmt);
    }
    const r = await this.db.query(stmt, [created_at]);
    return r.rowCount;
  }

  async createUser(name, email, address, isadmin) {
    let stmt = this._stmts.get('createUser');
    if (!stmt) {
      stmt = `INSERT INTO users (name, email, address, isadmin) VALUES ($1, $2, $3, $4);`;
      this._stmts.set('createUser', stmt);
    }
    const r = await this.db.query(stmt, [name, email, address, isadmin]);
    return r.rowCount;
  }

  async createPost(user_id, category_id, title, content) {
    let stmt = this._stmts.get('createPost');
    if (!stmt) {
      stmt = `INSERT INTO posts (user_id, category_id, title, content) VALUES ($1, $2, $3, $4);`;
      this._stmts.set('createPost', stmt);
    }
    const r = await this.db.query(stmt, [user_id, category_id, title, content]);
    return r.rowCount;
  }

  async createComment(post_id, user_id, content) {
    let stmt = this._stmts.get('createComment');
    if (!stmt) {
      stmt = `INSERT INTO comments (post_id, user_id, content) VALUES ($1, $2, $3);`;
      this._stmts.set('createComment', stmt);
    }
    const r = await this.db.query(stmt, [post_id, user_id, content]);
    return r.rowCount;
  }

  async createCategory(name) {
    let stmt = this._stmts.get('createCategory');
    if (!stmt) {
      stmt = `INSERT INTO categories (name) VALUES ($1);`;
      this._stmts.set('createCategory', stmt);
    }
    const r = await this.db.query(stmt, [name]);
    return r.rowCount;
  }

  async getPostsByCategory(category_id) {
    let stmt = this._stmts.get('getPostsByCategory');
    if (!stmt) {
      stmt = `SELECT p.id, p.title, p.content, u.name as author_name, p.created_at FROM posts p INNER JOIN users u ON p.user_id = u.id WHERE p.category_id = $1 ORDER BY p.created_at DESC;`;
      this._stmts.set('getPostsByCategory', stmt);
    }
    const r = await this.db.query(stmt, [category_id]);
    return r.rows;
  }

  async getComplexUserAnalytics(total_posts, total_comments, limit) {
    let stmt = this._stmts.get('getComplexUserAnalytics');
    if (!stmt) {
      stmt = `WITH user_post_stats AS ( SELECT u.id as user_id, u.name, u.email, u.role, u.isadmin, u.created_at as user_created_at, COUNT(DISTINCT p.id) as total_posts, COUNT(DISTINCT CASE WHEN p.status = 'published' THEN p.id END) as published_posts, COUNT(DISTINCT CASE WHEN p.status = 'draft' THEN p.id END) as draft_posts, MAX(p.created_at) as last_post_date, AVG(LENGTH(p.content)) as avg_post_length FROM users u LEFT JOIN posts p ON u.id = p.user_id GROUP BY u.id, u.name, u.email, u.role, u.isadmin, u.created_at ), user_comment_stats AS ( SELECT u.id as user_id, COUNT(c.id) as total_comments, COUNT(DISTINCT c.post_id) as posts_commented_on, MAX(c.created_at) as last_comment_date FROM users u LEFT JOIN comments c ON u.id = c.user_id GROUP BY u.id ), category_engagement AS ( SELECT p.user_id, COUNT(DISTINCT p.category_id) as categories_used, STRING_AGG(DISTINCT cat.name, ', ' ORDER BY cat.name) as category_names FROM posts p INNER JOIN categories cat ON p.category_id = cat.id GROUP BY p.user_id ) SELECT ups.user_id as id, ups.name, ups.email, ups.role, ups.isadmin, ups.user_created_at, COALESCE(ups.total_posts, 0) as total_posts, COALESCE(ups.published_posts, 0) as published_posts, COALESCE(ups.draft_posts, 0) as draft_posts, COALESCE(ucs.total_comments, 0) as total_comments, COALESCE(ucs.posts_commented_on, 0) as posts_commented_on, COALESCE(ce.categories_used, 0) as categories_used, COALESCE(ce.category_names, '') as category_names, ups.last_post_date, ucs.last_comment_date, COALESCE(ups.avg_post_length, 0)::NUMERIC(10,2) as avg_post_length, CASE WHEN ups.total_posts > 10 AND ucs.total_comments > 20 THEN 'highly_active' WHEN ups.total_posts > 5 OR ucs.total_comments > 10 THEN 'active' WHEN ups.total_posts > 0 OR ucs.total_comments > 0 THEN 'casual' ELSE 'inactive' END as activity_level, (COALESCE(ups.total_posts, 0) + COALESCE(ucs.total_comments, 0)) as engagement_score FROM user_post_stats ups LEFT JOIN user_comment_stats ucs ON ups.user_id = ucs.user_id LEFT JOIN category_engagement ce ON ups.user_id = ce.user_id WHERE ups.total_posts > $1 OR ucs.total_comments > $2 ORDER BY engagement_score DESC, ups.last_post_date DESC NULLS LAST LIMIT $3;`;
      this._stmts.set('getComplexUserAnalytics', stmt);
    }
    const r = await this.db.query(stmt, [total_posts, total_comments, limit]);
    return r.rows;
  }

  async getPostDetailsWithAllRelations(id) {
    let stmt = this._stmts.get('getPostDetailsWithAllRelations');
    if (!stmt) {
      stmt = `SELECT p.id, p.title, p.content, p.status, p.created_at, p.updated_at, u.id as author_id, u.name as author_name, u.email as author_email, u.role as author_role, u.isadmin as author_is_admin, cat.id as category_id, cat.name as category_name, COUNT(DISTINCT c.id) as comment_count, COUNT(DISTINCT c.user_id) as unique_commenters, STRING_AGG(DISTINCT c.content, ' | ' ORDER BY c.content) as all_comments, ARRAY_AGG(DISTINCT cu.name ORDER BY cu.name) as commenter_names, MAX(c.created_at) as last_comment_date, LENGTH(p.content) as content_length, EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600 as hours_since_created FROM posts p INNER JOIN users u ON p.user_id = u.id INNER JOIN categories cat ON p.category_id = cat.id LEFT JOIN comments c ON p.id = c.post_id LEFT JOIN users cu ON c.user_id = cu.id WHERE p.id = $1 GROUP BY p.id, p.title, p.content, p.status, p.created_at, p.updated_at, u.id, u.name, u.email, u.role, u.isadmin, cat.id, cat.name;`;
      this._stmts.set('getPostDetailsWithAllRelations', stmt);
    }
    const r = await this.db.query(stmt, [id]);
    return r.rows[0] || null;
  }

}

module.exports = { Queries };
