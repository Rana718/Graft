# Code generated by FlashORM. DO NOT EDIT.

from dataclasses import dataclass
from typing import Optional, List, Any
from datetime import datetime

@dataclass
class GetuserbyemailRow:
    id: int
    name: str
    address: Optional[str]
    isadmin: bool
    email: str
    created_at: datetime
    updated_at: datetime
    role: str

@dataclass
class CreatecategoryRow:
    id: int
    name: str
    created_at: datetime

@dataclass
class CreatepostRow:
    id: int
    user_id: int
    category_id: int
    title: str
    content: str
    created_at: datetime
    updated_at: datetime
    status: str

@dataclass
class CreatecommentRow:
    id: int
    post_id: int
    user_id: int
    content: str
    created_at: datetime

@dataclass
class GetpostwithcommentsRow:
    post_id: str
    title: str
    content: str
    author: str
    comment_text: str
    commenter: str

@dataclass
class GetpostdetailswithallrelationsRow:
    id: int
    title: str
    content: str
    status: str
    created_at: datetime
    updated_at: datetime
    author_id: str
    author_name: str
    author_email: str
    author_role: str
    author_is_admin: str
    category_id: int
    category_name: str
    comment_count: str
    unique_commenters: str
    all_comments: str
    commenter_names: str
    last_comment_date: str
    content_length: str
    hours_since_created: str

@dataclass
class GetcomplexuseranalyticsRow:
    id: int
    name: str
    email: str
    role: str
    isadmin: bool
    user_created_at: str
    total_posts: str
    published_posts: str
    draft_posts: str
    total_comments: str
    posts_commented_on: str
    categories_used: str
    category_names: str
    last_post_date: str
    last_comment_date: str
    avg_post_length: str
    activity_level: str
    engagement_score: str

class Queries:
    def __init__(self, db):
        self.db = db
        self._stmts = {}

    async def create_user(self, name: str, email: str, address: str, isadmin: bool) -> int:
        stmt = """INSERT INTO users (name, email, address, isadmin) VALUES ($1, $2, $3, $4);"""
        result = await self.db.fetch(stmt, name, email, address, isadmin)
        return len(result)

    async def get_user_by_email(self, email: str) -> Optional[GetuserbyemailRow]:
        stmt = """SELECT * FROM users WHERE email = $1;"""
        result = await self.db.fetch(stmt, email)
        return GetuserbyemailRow(**dict(result[0])) if result else None

    async def create_category(self, name: str) -> Optional[CreatecategoryRow]:
        stmt = """INSERT INTO categories (name) VALUES ($1) RETURNING *;"""
        result = await self.db.fetch(stmt, name)
        return CreatecategoryRow(**dict(result[0])) if result else None

    async def create_post(self, user_id: int, category_id: int, title: str, content: str) -> Optional[CreatepostRow]:
        stmt = """INSERT INTO posts (user_id, category_id, title, content) VALUES ($1, $2, $3, $4) RETURNING *;"""
        result = await self.db.fetch(stmt, user_id, category_id, title, content)
        return CreatepostRow(**dict(result[0])) if result else None

    async def create_comment(self, post_id: int, user_id: int, content: str) -> Optional[CreatecommentRow]:
        stmt = """INSERT INTO comments (post_id, user_id, content) VALUES ($1, $2, $3) RETURNING *;"""
        result = await self.db.fetch(stmt, post_id, user_id, content)
        return CreatecommentRow(**dict(result[0])) if result else None

    async def get_post_with_comments(self, id: int) -> List[GetpostwithcommentsRow]:
        stmt = """SELECT p.id AS post_id, p.title, p.content, u.name AS author, c.content AS comment_text, cu.name AS commenter FROM posts p JOIN users u ON p.user_id = u.id LEFT JOIN comments c ON p.id = c.post_id LEFT JOIN users cu ON c.user_id = cu.id WHERE p.id = $1;"""
        result = await self.db.fetch(stmt, id)
        return [GetpostwithcommentsRow(**dict(row)) for row in result]

    async def get_post_details_with_all_relations(self, id: int) -> Optional[GetpostdetailswithallrelationsRow]:
        stmt = """SELECT p.id, p.title, p.content, p.status, p.created_at, p.updated_at, u.id as author_id, u.name as author_name, u.email as author_email, u.role as author_role, u.isadmin as author_is_admin, cat.id as category_id, cat.name as category_name, COUNT(DISTINCT c.id) as comment_count, COUNT(DISTINCT c.user_id) as unique_commenters, STRING_AGG(DISTINCT c.content, ' | ' ORDER BY c.content) as all_comments, ARRAY_AGG(DISTINCT cu.name ORDER BY cu.name) as commenter_names, MAX(c.created_at) as last_comment_date, LENGTH(p.content) as content_length, EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600 as hours_since_created FROM posts p INNER JOIN users u ON p.user_id = u.id INNER JOIN categories cat ON p.category_id = cat.id LEFT JOIN comments c ON p.id = c.post_id LEFT JOIN users cu ON c.user_id = cu.id WHERE p.id = $1 GROUP BY p.id, p.title, p.content, p.status, p.created_at, p.updated_at, u.id, u.name, u.email, u.role, u.isadmin, cat.id, cat.name;"""
        result = await self.db.fetch(stmt, id)
        return GetpostdetailswithallrelationsRow(**dict(result[0])) if result else None

    async def get_complex_user_analytics(self, total_posts: int, total_comments: int, limit: int) -> List[GetcomplexuseranalyticsRow]:
        stmt = """WITH user_post_stats AS ( SELECT u.id as user_id, u.name, u.email, u.role, u.isadmin, u.created_at as user_created_at, COUNT(DISTINCT p.id) as total_posts, COUNT(DISTINCT CASE WHEN p.status = 'published' THEN p.id END) as published_posts, COUNT(DISTINCT CASE WHEN p.status = 'draft' THEN p.id END) as draft_posts, MAX(p.created_at) as last_post_date, AVG(LENGTH(p.content)) as avg_post_length FROM users u LEFT JOIN posts p ON u.id = p.user_id GROUP BY u.id, u.name, u.email, u.role, u.isadmin, u.created_at ), user_comment_stats AS ( SELECT u.id as user_id, COUNT(c.id) as total_comments, COUNT(DISTINCT c.post_id) as posts_commented_on, MAX(c.created_at) as last_comment_date FROM users u LEFT JOIN comments c ON u.id = c.user_id GROUP BY u.id ), category_engagement AS ( SELECT p.user_id, COUNT(DISTINCT p.category_id) as categories_used, STRING_AGG(DISTINCT cat.name, ', ' ORDER BY cat.name) as category_names FROM posts p INNER JOIN categories cat ON p.category_id = cat.id GROUP BY p.user_id ) SELECT ups.user_id as id, ups.name, ups.email, ups.role, ups.isadmin, ups.user_created_at, COALESCE(ups.total_posts, 0) as total_posts, COALESCE(ups.published_posts, 0) as published_posts, COALESCE(ups.draft_posts, 0) as draft_posts, COALESCE(ucs.total_comments, 0) as total_comments, COALESCE(ucs.posts_commented_on, 0) as posts_commented_on, COALESCE(ce.categories_used, 0) as categories_used, COALESCE(ce.category_names, '') as category_names, ups.last_post_date, ucs.last_comment_date, COALESCE(ups.avg_post_length, 0)::NUMERIC(10,2) as avg_post_length, CASE WHEN ups.total_posts > 10 AND ucs.total_comments > 20 THEN 'highly_active' WHEN ups.total_posts > 5 OR ucs.total_comments > 10 THEN 'active' WHEN ups.total_posts > 0 OR ucs.total_comments > 0 THEN 'casual' ELSE 'inactive' END as activity_level, (COALESCE(ups.total_posts, 0) + COALESCE(ucs.total_comments, 0)) as engagement_score FROM user_post_stats ups LEFT JOIN user_comment_stats ucs ON ups.user_id = ucs.user_id LEFT JOIN category_engagement ce ON ups.user_id = ce.user_id WHERE ups.total_posts > $1 OR ucs.total_comments > $2 ORDER BY engagement_score DESC, ups.last_post_date DESC NULLS LAST LIMIT $3;"""
        result = await self.db.fetch(stmt, total_posts, total_comments, limit)
        return [GetcomplexuseranalyticsRow(**dict(row)) for row in result]

