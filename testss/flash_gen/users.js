// Code generated by FlashORM. DO NOT EDIT.

class Queries {
  constructor(db) {
    this.db = db;
    this._stmts = new Map();
  }

  async createUser(name, email) {
    let stmt = this._stmts.get('createUser');
    if (!stmt) {
      stmt = `INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *;`;
      this._stmts.set('createUser', stmt);
    }
    const r = await this.db.query(stmt, [name, email]);
    return r.rows[0] || null;
  }

  async getUser(id) {
    let stmt = this._stmts.get('getUser');
    if (!stmt) {
      stmt = `SELECT * FROM users WHERE id = $1;`;
      this._stmts.set('getUser', stmt);
    }
    const r = await this.db.query(stmt, [id]);
    return r.rows[0] || null;
  }

  async getUserByEmail(email) {
    let stmt = this._stmts.get('getUserByEmail');
    if (!stmt) {
      stmt = `SELECT * FROM users WHERE email = $1;`;
      this._stmts.set('getUserByEmail', stmt);
    }
    const r = await this.db.query(stmt, [email]);
    return r.rows[0] || null;
  }

  async createCategory(name) {
    let stmt = this._stmts.get('createCategory');
    if (!stmt) {
      stmt = `INSERT INTO categories (name) VALUES ($1) RETURNING *;`;
      this._stmts.set('createCategory', stmt);
    }
    const r = await this.db.query(stmt, [name]);
    return r.rows[0] || null;
  }

  async createPost(user_id, category_id, title, content) {
    let stmt = this._stmts.get('createPost');
    if (!stmt) {
      stmt = `INSERT INTO posts (user_id, category_id, title, content) VALUES ($1, $2, $3, $4) RETURNING *;`;
      this._stmts.set('createPost', stmt);
    }
    const r = await this.db.query(stmt, [user_id, category_id, title, content]);
    return r.rows[0] || null;
  }

  async createComment(post_id, user_id, content) {
    let stmt = this._stmts.get('createComment');
    if (!stmt) {
      stmt = `INSERT INTO comments (post_id, user_id, content) VALUES ($1, $2, $3) RETURNING *;`;
      this._stmts.set('createComment', stmt);
    }
    const r = await this.db.query(stmt, [post_id, user_id, content]);
    return r.rows[0] || null;
  }

  async getPostWithComments(id) {
    let stmt = this._stmts.get('getPostWithComments');
    if (!stmt) {
      stmt = `SELECT p.id AS post_id, p.title, p.content, u.name AS author, c.content AS comment_text, cu.name AS commenter FROM posts p JOIN users u ON p.user_id = u.id LEFT JOIN comments c ON p.id = c.post_id LEFT JOIN users cu ON c.user_id = cu.id WHERE p.id = $1;`;
      this._stmts.set('getPostWithComments', stmt);
    }
    const r = await this.db.query(stmt, [id]);
    return r.rows;
  }

  async getPostDetailsWithAllRelations(id) {
    let stmt = this._stmts.get('getPostDetailsWithAllRelations');
    if (!stmt) {
      stmt = `SELECT p.id, p.title, p.content, p.status, p.created_at, p.updated_at, u.id as author_id, u.name as author_name, u.email as author_email, u.role as author_role, u.isadmin as author_is_admin, cat.id as category_id, cat.name as category_name, COUNT(DISTINCT c.id) as comment_count, COUNT(DISTINCT c.user_id) as unique_commenters, STRING_AGG(DISTINCT c.content, ' | ' ORDER BY c.content) as all_comments, ARRAY_AGG(DISTINCT cu.name ORDER BY cu.name) as commenter_names, MAX(c.created_at) as last_comment_date, LENGTH(p.content) as content_length, EXTRACT(EPOCH FROM (NOW() - p.created_at)) / 3600 as hours_since_created FROM posts p INNER JOIN users u ON p.user_id = u.id INNER JOIN categories cat ON p.category_id = cat.id LEFT JOIN comments c ON p.id = c.post_id LEFT JOIN users cu ON c.user_id = cu.id WHERE p.id = $1 GROUP BY p.id, p.title, p.content, p.status, p.created_at, p.updated_at, u.id, u.name, u.email, u.role, u.isadmin, cat.id, cat.name;`;
      this._stmts.set('getPostDetailsWithAllRelations', stmt);
    }
    const r = await this.db.query(stmt, [id]);
    return r.rows[0] || null;
  }

}

module.exports = { Queries };
